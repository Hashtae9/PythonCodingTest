# 면접 7-2일차

## 1. OSI 7계층이 존재하는 목적에 대해 말해주세요

### OSI 7계층

+ OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것



### 계층을 나눈 이유

+ 통신이 일어나는 과정을 단계 별로 파악할 수 있기 때문이다. 
+ 흐름을 한 눈에 알아보기 쉽고, 사람들이 이해하기 쉽고, 7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건드리지 않고도 이상이 생긴 단계만 고칠 수 있다.

```
PC방에서 오버워치를 하는데 연결이 끊겼다. 어디에 문제가 있는지 확인해 보자.
모든 PC에 문제가 있다면, 라우터의 문제(3계층 네트워크 계층)이거나 
광랜을 제공하는 회사의 회선 문제(1계층 물리 계층)일 가능성이 높다.

한 PC만 문제가 있다면, 오버워치 소프트웨어에 문제(7계층 애플리케이션 계층)일 수 있다.
오버워치 소프트웨어에 문제가 없고, 스위치에 문제(2계층 데이터 링크 계층)일 수 있다.

이렇듯 다른 계층에 있는 장비나 소프트웨어를 건드리지 않고 문제를 해결할 수 있다.
```



### 1계층 - 물리 계층 (Physical Layer)

물리 계층에서는 주로 전기적, 기계적, 기능적인 특성을 이용한 통신 케이블로 데이터를 전송

사용되는 통신 단위는 비트이며 1과 0으로 나뉘어지는 즉, 전기적으로 On, Off 상태

통신 케이블, 리피터, 허브



### 2계층 - 데이터 링크 계층 (DataLink Layer)

물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와준다. 따라서 통신에서의 오류도 찾아주고, 오류가 있다면 데이터를 재전송하는 기능을 가지고 있다. 
오류 검사는 패리티 비트 검사, 해밍 부호 검사 등이 있다.

 

데이터 링크 계층은 맥 주소를 가지고 통신하며, 전송되는 단위를 프레임이라고 하고, 대표적인 장비로는 브릿지와 스위치 등이 있다. 브릿지와 스위치 등에서 **맥 주소**를 활용한다.



### 3계층 - 네트워크 계층 (Network Layer)

네트워크 계층은 경로를 선택하고 주소를 정한 뒤, 경로에 따라 패킷을 전달해 주는 역할을 한다. 이 계층의 대표적인 장비는 라우터이며, 요즘은 2계층의 장비 중 스위치라는 장비에 **라우팅** 기능을 장착한 Layer 3 스위치도 있다. 라우터에서 **IP 주소**를 활용하며, 위에서 언급한 주소를 정한다는 것이 바로 IP 주소를 의미한다. 참고로 네이버나 구글 같은 도메인 주소를 55.10.54.75 같은 IP 주소로 변환하는 행위를 **DNS**라고 한다.



### 4계층 - 전송 계층 (Transport Layer)

전송 계층에서는 데이터를 전송하고, 전송 속도를 조절하며, 오류가 발생된 부분은 다시 맞춰 주는 계층이다. 데이터를 전송 받은 경우, 전송 계층에서 데이터를 합산하여 세션 계층으로 보내주게 된다.

주로 TCP, UDP 프로토콜을 사용하며, 헤더에 송신지와 수신지의 **포트 번호**를 포함하여 전달하는 계층이다. 참고로, TCP의 데이터 전송 단위는 Segment, UDP의 데이터 전송 단위는 Datagram이라고 부른다.

 

**포트 번호란?**

하나의 컴퓨터에서 동시에 실행되고 있는 프로세스들이 서로 겹치지 않게 가져야 하는 정수 값이다.

 

**네트워크 계층 vs 전송 계층**

네트워크 계층은 호스트 간의 논리적 통신을 돕지만, 전송 계층은 응용 프로세스 간의 논리적을 통신을 돕는다.



### 5계층 - 세션 계층

세션 계층은 네트워크상 양쪽 연결을 관리하고 연결을 지속 시켜 주는 계층이다. 주로, TCP/IP 세션을 만들고 유지하며, 세션이 종료되거나 전송이 중단될 시 복구하는 기능이 있다. 더불어, 통신하는 사용자들을 동기화한다는 특징이 있다.

통신 연결은 포트 기반으로 구성하여 연결하며, 운영 체제가 통신을 하기 위한 세션 확립/유지/중단 과정을 해 준다.

 

**세션이란?**

세션이란 일정 시간 동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지하는 기술을 말한다. 여기서 일정 시간이란, 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저는 종료함으로써 연결을 끝내기 까지의 기간을 말한다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 부른다.

 

### 6계층 - 표현 계층

표현 계층은 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식 상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다. MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.

예를 들어, EBCDID로 인코딩된 문서 파일을 ASCII로 인코딩된 파일로 바꿔 주는 것이나 특정 데이터가 text인지, gif인지, jpg인지 등의 구분을 해 준다.



### 7계층 - 응용 계층

응용 계층은 사용자 또는 애플리케이션이 네트워크 접근할 수 있도록 해 준다. 사용자를 위한 인터페이스를 제공하며, 사용자에게 보이는 유일한 계층이라고 할 수 있다. 메일 전송, 인터넷 접속 등의 작업을 수행할 수 있다. 최종 목적지로서 HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.



## 2. API란 무엇인가요? + 3. 그렇다면 REST API란 무엇인가요?

### 인터페이스

+ 사물과 인간 사이의 경계에서 상호 간의 소통을 위해 만들어진 물리적 매개체나 프로토콜
+ TV 리모콘 전원 버튼은 인터페이스다. 사람이 리모콘 버튼을 눌러 TV가 켜지도록 연결하는 매개체이기 때문



### **API(Application Programming Interface)**

애플리케이션(응용프로그램)에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. 즉, **애플리케이션이 어떤 프로그램이 제공하는 기능을 사용할 수 있게 만든 매개체**다. 

컴퓨터와 인간을 연결시키는 사용자 인터페이스(UI)와 반대로, **API는 컴퓨터나 소프트웨어를 서로 연결**한다.



서버는 프로그램에게 자신이 제공하고자 하는 데이터나 기능을 제어할 수 있는 **API**로 만들면, 접근 권한이 있는 프로그래머나 프로그램이 API를 통해 서버에서 제공하는 데이터를 요청해서 사용할 수 있게 된다.



### HTTP API

+ HTTP를 사용하여 프로그램끼리 소통하는 API를 말한다. 보통 우리가 흔히 보는 OPEN API, facebook API, kakao API 등의 대부분 API는 HTTP라는 통신 규칙으로 소통하는 API
+ 세먼지 측정기에서 미세먼지 농도 값을 읽어와서 공기가 안 좋으면, 자동으로 창문을 개방하는 IoT**어플리케이션**을 개발하고 싶다고 하자. 미세먼지 측정기와 스마트 창문이 IoT 애플리케이션과 통신(소통)할 수 있는 API가 있어야 한다.
  이때 사용하는 소통 방법은 HTTP통신이 아닌 저사양/저전력 환경에 적합한 MQTT, CoAP프로콜을 사용해야 한다. 



### **REST API**

+ **REST(Representational State Transfer)**란 네트워크 아키텍처 스타일
  + 네트워크 아키텍처 스타일 : 네트워크 자원을 정의하고 처리하는 방법 전반
+ REST는 HTTP를 잘 활용하기 위한 원칙이라고 할 수 있고 REST API는 이 원칙을 준수해 만든 API
+ **URI로 자원을 표현**하는 데에 집중하고, 자원의 **상태(행위)에 대한 정의는 HTTP METHOD**로 하는 것이 REST한 API를 설계하는 중심 규칙
  + **URI로 자원(리소스)을 표현**해야 한다.
  + 자원에 대한 행위는 **HTTP Method(GET, POST, PUT, DELETE)**로 표현된다.



**REST API**는 HTTP 프로토콜을 따르면서 아래의 4가지 가이드 원칙을 지켜야 한다.

1) 자원의 식별
2) 메세지를 통한 리소스 조작
3) 자기서술적 메세지
4) 애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어(HATEOAS)





## 4.세션과 쿠키의 차이점에 대해 말해주세요(3가지)

### **쿠키와 세션을 사용하는 이유?**

HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용한다.



#### **HTTP 프로토콜의 특징**

1. **Connectionless 프로토콜 (비연결 지향)**

 클라이언트가 서버에 요청(Request)을 했을 때, 그 요청에 맞는 응답(Response)을 보낸 후 **연결을 끊는 처리방식**이다.

- HTTP 1.1 버전에서 커넥션을 계속 유지하고, 요청(Request)에 재활용하는 기능이 추가되었다. (HTTP Header)에 keep-alive 옵션을 주어 커넥션을 재활용하게 한다. HTTP 1.1 버전에선 디폴트(default) 옵션이다.
- HTTP가 TCP위에서 구현되었기 때문에(TCP : 연결 지향, UDP : 비연결 지향) 연결 지향적이라고 할 수 있다는 얘기가 있어 논란이 있지만, 아직까진 네트워크 관점에서 keep-alive는 옵션으로 두고, 서버 측에서 비연결 지향적인 특성으로 커넥션 관리에 대한 비용을 줄이는 것이 명확한 장점으로 보기 때문에 비연결 지향으로 알아두었다.
- **Stateless 프로토콜**

 커넥션을 끊는 순간 클라이언트와 서버의 통신이 끝나며 **상태 정보는 유지하지 않는 특성**이 있다.

- 클라이언트와 첫 번째 통신에서 데이터를 주고받았다 해도, 두 번째 통신에서 이전 데이터를 유지하지 않는다.
- 하지만, 실제로는 데이터 유지가 필요한 경우가 많다.



### **쿠키(Cookie)**

HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우,

그 사이트가 사용하고 있는 서버에서 <span style = color:red>**사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**</span>이다.

HTTP에서 클라이언트의 상태 정보를 **클라이언트의 PC에 저장**하였다가 **필요시 정보를 참조하거나 재사용할 수 있다.**

 

- **쿠키 특징**
  1. 이름, 값, 만료일(저장기간), 경로 정보로 구성되어 있다.
  2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
  3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
  4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.
- **쿠키의 동작 순서**
  1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트에 접근)
  2. 웹 서버는 쿠키를 생성한다.
  3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다.
  4. 넘겨받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장) 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
  5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송한다.
- **사용 예시**
  1. 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
  2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크

------

### **세션(Session)**

일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술이다.

여기서 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.

즉, **방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다.**

 

- **세션 특징**
  1. <span style = color:red>**웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장**</span>한다.
  2. 웹 서버의 저장되는 쿠키(=세션 쿠키)
  3. 브라우저를 닫거나, 서버에서 세션을 삭제했을 때만 삭제가 되므로, 쿠키보다 비교적 보안이 좋다.
  4. 저장 데이터에 제한이 없다. (서버 용량이 허용하는 한에서)
  5. 각 클라이언트에 고유 Session ID를 부여한다. Session ID로 클라이언트를 구분해 각 요구에 맞는 서비스를 제공
- **세션의 동작 순서**
  1. 클라이언트가 페이지에 요청한다. (사용자가 웹사이트에 접근)
  2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 클라이언트가 해당 session-id를 보냈는지 확인한다.
  3. session-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 돌려준다.
  4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.
  5. 클라이언트는 재접속 시, 이 쿠키를 이용해 session-id 값을 서버에 전달
- **사용 예시**
  - 화면을 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지



### **쿠키와 세션의 차이**

- 쿠키와 세션은 비슷한 역할을 하며, 동작 원리도 비슷하다. 그 이유는 세션도 결국 쿠키를 사용하기 때문이다.
- 큰 차이점은 **사용자의 정보가 저장되는 위치**이다. **쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용**한다.
- **보안 면에서 세션이 더 우수**하며,
- 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만
- 세션은 쿠키를 이용해서 session-id만 저장하고 그것으로 구분하여 서버에서 처리하기 때문에 비교적 보안성이 높다.
- **라이프 사이클**은 쿠키도 만료기간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 정보가 유지될 수 있다. 또한 만료기간을 따로 지정해 쿠키를 삭제할 때까지 유지할 수도 있다.
- 반면에 세션도 만료기간을 정할 수 있지만, 브라우저가 종료되면 만료기간에 상관없이 삭제된다.
- **속도 면에서 쿠키가 더 우수**하며,
- 쿠키는 쿠키에 정보가 있기 때문에 서버에 요청 시 속도가 빠르고
- 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

보통 쿠키와 세션의 차이에 대해서 저장 위치와 보안에 대해서는 잘 알고 있지만, 사실 가장 중요한 것은 **라이프사이클**이다.



### **Q. 세션을 사용하면 좋은데 왜 쿠키를 사용할까?**

**A.** 세션이 쿠키에 비해 보안이 높은 편이나 **쿠키를 사용하는 이유는 세션은 서버에 저장되고, 서버의 자원을 사용하기에**

   **서버 자원에 한계가 있고, 속도가 느려질 수 있기 때문에 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여**

   **서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다**.



### **쿠키와 세션 그리고 캐시(Cache)?**

**캐시(Cache)**는 **웹 페이지 요소를 저장하기 위한 임시 저장소**이고,

**쿠키/세션은 정보를 저장하기 위해 사용**된다.

**캐시**는 웹 페이지를 빠르게 렌더링 할 수 있도록 도와주고,

쿠키/세션은 사용자의 인증을 도와준다.

- 캐시는 이미지, 비디오, 오디오, css, js파일 등 데이터나 값을 미리 복사해 놓는 리소스 파일들의 임시 저장소이다.
- 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다.
- 같은 웹 페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 된다.
- 이전에 사용된 데이터가 다시 사용될 가능성이 많으면 캐시 서버에 있는 데이터를 사용한다.
- 그래서 다시 사용될 확률이 있는 데이터들이 빠르게 접근할 수 있어진다. (페이지의 로딩 속도 ↑)
- 캐시 히트(hit) : 캐시를 사용할 수 있는 경우 (ex. 이전에 왔던 요청이랑 같은 게 왔을 때)
- 캐시 미스(miss) : 캐시를 사용할 수 없는 경우 (ex. 웹서버로 처음 요청했을 때)



## 5. TCP와 TCP/IP에 대해 각각 설명해주세요

### TCP/IP

**TCP/IP** 는 TCP 프로토콜과 IP 프로토콜을 아울러 지칭하는 용어이다. **TCP** 프로토콜은 **신뢰성 있고 무결성을 보장하는 연결을 통해 데이터를 안전하게 전달해주는 전송 프로토콜**이고, **IP** 프로토콜은 **패킷들을 가장 효율적인 방법으로 최종 목적지로 전송하기 위해 필요한 프로토콜**이다.(패킷 스위칭)

패킷 교환 방식에서, **네트워크가 사용하는 프로토콜에 의거하여 데이터를 캡슐화**하는데, 이 때 **TCP/IP 는 '프로토콜' 에 해당**하게 된다. **TCP/IP 가 제시하는대로 데이터를 캡슐화**하는것이다. TCP/IP 말고도 지금까지 많은 프로토콜이 제시되어 왔겠지만, 가장 이상적이고 효율적인 프로토콜이어서 그런지 거의 표준화된 것 같다.

> **TCP/IP 프로토콜을 따르는 네트워크 통신**이라면, 송신 호스트에서 전송할 데이터를 **TCP/IP 4계층이라는 계층 구조에 따라 순차적으로 캡슐화를 하여 네트워크에 전송**하게 된다. 그리고 **데이터를 수신하는 호스트**에서도 이 계층 구조에 따라 캡슐화된 패킷을 **역순으로 포장을 뜯어가며 원래 데이터를 확인**해볼 수 있게 되는 것이다.



### **TCP/UDP란**

 TCP와 UDP는 함께 클라이언트와 서버 간의 통신 채널의 제공, 통신을 관리하며, 레이어4의 프로토콜이다. 통신 채널이란 말하자면 "포트"라는 것으로 1번부터 65535번까지의 번호가 사용된다. 동일한 IP 주소라도 TCP나 UDP의 포트가 다르면 제공되는 서비스가 달라진다. 참고로 포트 번호는 3개의 타입으로 분류할 수 있다.



### **UDP의 특징**

 UDP는 커넥션리스형의 프로토콜로 TCP와 비교하여 신뢰성이 없지만 고속통신이 가능하다. 또한 UDP 헤더 사이즈(8byte)가 작아 그 만큼 어플리케이션의 데이터를 많이 송수신하는 것이 가능하다. 그러나 패킷이 도달한다고 보장할 수 없기 때문에 패킷 손실의 경우 어플리케이션쪽에서 재전송 처리를 하여 통신을 성립시키거나, 패킷 손실이 용인되는 응용 프로그램이 필요하다.



## 6. 그렇다면 인터넷브라우저(크롬 등)의 주소창에 [www.naver.com을](http://www.naver.xn--com-of0o/) 입력했을때 동작과정을 설명해주세요



### 인터넷 브라우저와 구조

먼저 인터넷 브라우저가 무엇인지 살펴보고, 그 구조에 대해 알아보자.

**인터넷 브라우저**란 웹 서버와 통신하여 인터넷 사이트 및 다양한 컨텐츠를 볼 수 있도록 지원해주는 소프트웨어 프로그램이다.

인터넷 브라우저는 현재 가장 많이 사용되는 Chrome을 포함하여 Safari, Firefox, 오페라 등 여러 종류가 있다. 각 브라우저마다 전반적인 구조는 조금씩 다르지만 큰 틀은 아래의 그림으로 동일하다.

![img](https://velog.velcdn.com/images/sylagape1231/post/78c816ae-4739-42eb-9f32-04322806b154/image.png)

인터넷 브라우저의 구조 (👉[사진 출처](https://d2.naver.com/helloworld/59361))

- **사용자 인터페이스 (User Interface / UI)**
  - 페이지를 보여주는 창을 제외한 나머지 모든 영역을 말한다.
  - 주소 표시줄, 이전, 이후 버튼, 홈버튼, 북마크 버튼 등

- **브라우저 엔진 / 레이아웃 엔진**
  - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.
  - (UI를 그리는 **UI 스레드**, 네트워크 통신을 위한 **네트워크 스레드**, 파일에 접근하기 위한 **스토리지 스레드** 등이 존재한다.)

- **렌더링 엔진**
  - 브라우저 엔진과 밀접히 관련된 엔진으로, 웹 페이지가 표시되는 모든 영역을 제어한다.
  - 요청한 콘텐츠(HTML, CSS 등)를 파싱하고, 화면에 나타내는 일을 수행한다.

- **자료 저장소 / 데이터 저장소**
  - 말 그대로 자료 저장소다.
  - 쿠키나, localStorage, IndexedDB 같이 로컬에 저장되어 좀 더 오래 유지되어야 하는 데이터들을 보관할 수 있도록 지원하는 영역이다.

- **통신 (Networking)**
  - HTTP/HTTPS 네트워크 처리를 한다.
  - 플랫폼과 독립적인 인터페이스로, 각 플랫폼의 하부에서 실행된다.

- **자바스크립트 해석기 (JS Interpreter) / 자바스크립트 엔진**

  - 스크립트(JS 코드)를 파싱(해석)할 때 사용하는 JS 엔진이다.

  - HTML을 파싱(해석) 중

     

    ```
    script
    ```

     

    태그를 만나면, JS 엔진이 제어 권한을 넘겨받는다.

    이 작업은 동기적으로 진행된다.

    > '동기적으로 진행된다'의 의미 :
    > JS 엔진이 작업을 마칠 때까지 HTML에서 진행 중인 과정은 잠시 중지된다.

- **UI 백엔드 (UI Backend)**
  - 기본 위젯을 그릴 때 이용한다.
  - OS의 방법을 사용한다.

모던 브라우저는 각각의 탭을 독립적으로 처리한다. 덕분에 높은 보안성과 더 좋은 사용성을 제공할 수 있다.

### DOM 트리

그 다음으로 DOM 트리에 대해 알아보자.

**DOM 트리**란 '문서 객체 모델 (Document Object Model)' 의 줄임말로, 쉽게 말해 **객체**로 표현된 **HTML 문서**이다.

브라우저는 HTML 텍스트 문서를 바로 읽을 수 없기 때문에, 이를 객체의 형태로 바꾸어 브라우저가 읽을 수 있는 **트리 구조**로 변환해주어야 한다. 이것이 바로 DOM 트리이다.

DOM 트리 내 하나의 객체는 **노드**라 부르며, DOM 트리는 총 4가지 노드로 구성되어 있다.

- **문서 노드 (Document Node)** : 트리의 최상위 객체. DOM 트리에 접근하기 위한 시작점.
- **요소 노드(Element Node)** : HTML 요소 (태그) 를 객체로 표현한 것
- **어트리뷰트 노드(Attribute Node)** : HTML 요소의 'Attribute'를 객체로 표현한 것
- **텍스트 노드(Text Node)** : HTML 요소의 '텍스트'를 객체로 표현한 것

![img](https://velog.velcdn.com/images/sylagape1231/post/7ea6913f-ede1-4697-bbe9-63b752077494/image.png)DOM 트리 구조 (👉[사진 출처](https://poiemaweb.com/js-dom))

외부에서 특정 노드에 접근하기 위해 DOM을 확인해야 할 때
DOM 트리는 최상위 노드인 '문서 노드' 부터 아래 방향으로 순차적으로 탐색된다.
자바스크립트를 통해 HTML 문서에 접근할 때, 혹은 페이지를 조작하는 이벤트가 발생할 때 이 과정이 일어난다.

그리고 DOM 트리 생성과정에서 브라우저는 HTML 문서에 있는 에러들을 자동으로 처리해준다.





## 💻 주소 창에 naver.com를 치면 일어나는 일

이제 주소 창에 `naver.com`를 치고 키보드의 Enter을 눌렀을 때 무슨 일이 일어나는지 본격적으로 살펴보자.

이 과정은 아래 그림처럼 총 **3단계**로 구분할 수 있다.

![img](https://velog.velcdn.com/images/sylagape1231/post/89eb542e-cb4d-40a8-b90e-2dbf351634ab/image.png)

### 📌 Step 1. 주소창에 입력한 텍스트 정보 확인

대부분의 인터넷 브라우저는 자사의 주소창을 검색창과 동일하게 사용하고 있다.
대표적으로 가장 많이 사용되고 있는 웹 브라우저인 Chrome은 주소창을 구글의 검색창으로도 쓰고 있다.

이럴 경우 브라우저는 사용자가 주소창에 어떤 텍스트를 입력했을 때,
이 텍스트가 **검색어**인지 **URL**인지 우선적으로 확인한다.
(이 작업의 주체는 브라우저 엔진의 UI 스레드이다.)

- 만일 입력한 텍스트가 **검색어**이면,
  브라우저는 검색 엔진의 URL에 검색어를 포함한 주소로 페이지를 이동시킨다.
- 만일 입력한 텍스트가 **URL**이면,
  브라우저 엔진에서 (네트워크 스레드를 통해) 네트워크 호출을 수행한다.

![img](https://velog.velcdn.com/images/sylagape1231/post/5f1075ad-c124-4ad9-8ce2-13df2e868b42/image.png)

따라서 주소창에 `naver.com`을 입력한 경우 브라우저는 **네트워크 호출**을 수행하게 된다.

### 📌 Step 2. 네트워크 호출

먼저 브라우저가 네트워크 호출을 왜 수행해야 하는지부터 간단하게 짚어보자.

브라우저가 사용자에게 '네이버'라는 사이트를 화면에 보여주려면
네이버의 HTML 문서, CSS 문서, 스크립트, 이미지 등의 데이터를 미리 가지고 있어야 한다.
하지만 현재 브라우저엔 이러한 정보가 없다.
이러한 데이터들은 네이버 서버 컴퓨터에 존재한다.

그렇기 때문에 브라우저는 네이버 서버와의 네트워크 통신을 통해 이러한 데이터들을 가져와야 한다.

이 작업을 수행하기 위해선, 브라우저는 우선 네이버 서버가 있는 컴퓨터의 IP 주소부터 파악할 필요가 있다.
마치 친구의 집에 혼자 찾아가려면 그 집의 주소를 알고 있어야 하는 것처럼 말이다.

따라서 '네트워크 호출' 과정은 크게 아래의 두 가지 과정으로 나누어 볼 수 있다.

> 1. 네이버 서버의 주소를 알기 위해 네임 서버(Name Server)와 통신하기
> 2. 알아낸 주소를 바탕으로 네이버 서버와 통신하여 필요한 데이터 응답받기

#### 1. 네이버 서버의 주소를 찾는 과정

네이버 서버의 주소를 알아내기 위해, **클라이언트**(사용자의 컴퓨터)는 다음의 과정을 수행한다.

> 1. 자신의 host 파일에서 도메인 네임(`naver.com`)에 대응하는 IP 주소(`125.209.222.142`)가 있는지 우선적으로 확인한다.
> 2. 만일 없다면, 네임 서버(Name Server)에 '네이버의 IP 주소를 알려주세요' 라는 요청을 보낸다.

여기서 **도메인 네임**이란 URL `www.naver.com`에서 `naver.com` 에 해당하는 부분이다.

인터넷은 컴퓨터의 주소인 **IP 주소**를 기반으로 동작한다.
하지만 우리가 인터넷을 사용할 땐, IP 주소 대신 사용하기 쉽도록 문자로 이루어진 도메인 네임을 사용한다.

따라서 도메인 네임을 IP 주소로 변환해 주는 환경인 **DNS (Domain Name Server)**가 반드시 필요한데, 이 DNS를 운영하는 장치를 **네임 서버 (Name Server)** 혹은 **DNS 서버**라 한다.

즉, 네임 서버는 도메인 주소에 대응하는 IP 주소를 찾아주는 역할을 수행하는 것이다.

클라이언트는 일반적으로 네임 서버의 IP 주소를 이미 가지고 있다.
따라서 클라이언트는 네임 서버와 통신이 가능하고, `naver.com`에 해당하는 IP 주소를 요청 및 응답 받을 수 있다.

#### 2. 네이버 서버와 통신하여 필요한 데이터를 받는 과정

이제 클라이언트는 네이버 서버의 IP 주소를 알게 되어 네이버 서버와 통신할 수 있게 되었다.
클라이언트의 브라우저는 (TCP 소켓을 열고 이를 통해) 네이버 서버에 데이터를 요청하는 **HTTP Request**를 보낸다.

HTTP Request를 받은 네이버 서버는 클라이언트가 요청한 문서를 찾아 읽고
이를 바이트 형태 (1과 0으로 이루어짐) 로 변환한 후, 클라이언트로 **HTTP Reply (HTTP Response)**를 보낸다.

![img](https://velog.velcdn.com/images/sylagape1231/post/ab81af0e-d089-434f-844d-3acf35581928/image.png)

### 📌 Step 3. 렌더링 작업

브라우저 엔진(의 네트워크 스레드)은 네이버 서버로부터 응답받은 데이터에 악성 바이러스가 있는지 우선 검사한다.

이 데이터는 바이트 형태의 텍스트 문서이므로, 브라우저 엔진이 읽을 수 없다.
따라서 브라우저 엔진(의 UI 스레드)은 **렌더링 엔진**에게 해당 데이터를 해석하고, 웹 페이지를 화면에 띄울 것을 요청한다.

요청을 받은 렌더링 엔진은 받은 데이터를 바탕으로 **렌더링 프로세스**를 수행하고, 이 과정이 끝나면 브라우저 엔진에게 작업 완료를 알린다.

그리고 화면에 네이버 페이지가 드디어 보여지게 된다.





## 📃 렌더링 프로세스

렌더링 엔진은 브라우저 엔진으로부터 요청받은 내용을 화면에 표시해주는 역할을 한다.
이 **렌더링 프로세스**에 대해 좀 더 자세히 알아보자.

![img](https://velog.velcdn.com/images/sylagape1231/post/9302efd9-544d-495d-9309-1a25ba00e074/image.png)

렌더링 과정은 아래 4가지 과정으로 이루어진다.

> 1. HTML을 파싱하여 **DOM 트리 구축**, CSS를 파싱하여 **CSSOM 트리 구축** (+ JS 파싱)
> 2. DOM 트리와 CSSOM 트리를 통해 **랜더 트리 구축** (Attachment / 형상 구축)
> 3. 랜더 트리 **배치** (Layout / Reflow)
> 4. 랜더 트리 **그리기** (Paint)

렌더링 과정에서 쓰이는 명칭은 인터넷 브라우저의 종류마다 조금씩 다르다. 그러나 렌더링 엔진의 기본적인 동작 과정은 브라우저의 종류와 상관없이 동일하다.

- **웹 브라우저 별 사용하는 렌더링 엔진**

  - 파이어폭스는 모질라에서 직접 만든 **게코(Gecko)** 엔진을 사용하고, 사파리는 **웹킷(Webkit)** 엔진을 사용한다.
  - 크롬은 웹킷(Webkit) 엔진을 사용했다가, 웹킷을 Fork하여 자체적으로 구현한 **블링크(Blink)** 엔진을 현재 사용하고 있다.

  ![img](https://velog.velcdn.com/images/sylagape1231/post/8eac59ec-efb5-4a2b-8cfb-137caab0b1c9/image.png)

  웹킷(+Blink)의 렌더링 프로세스 과정

  ![img](https://velog.velcdn.com/images/sylagape1231/post/78904788-612a-4ebe-9955-8392fd9ebf9c/image.png)게코의 렌더링 프로세스 과정

  (👉[사진 출처](https://d2.naver.com/helloworld/59361))

### 파싱 (Parsing) 이란?

렌더링 과정을 하나씩 설명하기에 앞서, 파싱의 개념부터 우선 이해하는 것이 중요하다.

앞서 말했다시피, 브라우저는 HTML, CSS 등 단순한 텍스트 문서를 이해하지 못한다.
따라서 이 문서를 브라우저가 이해할 수 있는 구조로 변환해주는 과정이 반드시 필요하다.
이를 **파싱 (Parsing)** 이라 한다.

파싱은 '어휘 분석'과 '구문 분석' 두 가지 과정으로 구분할 수 있다.

1. **어휘 분석** (By 어휘 분석기) : 문자열을 의미 있는 작은 단위인 **토큰(token)**으로 분해하는 과정

2. **구문 분석** (By 파서) : 문자열의 문법에 따라 토큰 간의 위계관계를 분석하여 **parsing 트리**를 생성하는 과정

   > 파싱 결과 생성되는 트리 형태를 **parse 트리, parsing 트리, concrete syntax 트리** 등 다양한 용어로 부른다.

   > parse 트리는 토큰화 된 문자열의 단순한 트리에 불과하므로, 이를 바로 사용할 순 없다.
   > 따라서 브라우저는 이 parse 트리를 DOM 트리로 바꾸어 사용한다.

![img](https://velog.velcdn.com/images/sylagape1231/post/00634798-fb01-4de9-becc-4b2f0808c0c8/image.png)

### 📌 Step 1-1. HTML 파싱 → DOM 트리 생성

렌더링 엔진이 HTML 문서를 수신받으면, HTML 파서는 이를 위에서부터 읽어 내려가며 파싱을 진행하고, 그 결과물로 **DOM 트리**를 생성한다.

- **HTML 파싱 과정**

  1. 서버에서 **바이트 형태**의 HTML 문서를 응답받는다.

  2. 지정된 인코딩 방식(UTF-8)에 따라 이를 **문자열**로 변환한다.

     ```html
     <meta charset="UTF-8">
     ```

  3. 변환된 문자열을 **토큰**으로 분해한다.

  4. 토큰을 내용에 따라 **객체(노드)**로 변환한다.

  5. 객체를 **트리 구조**로 구성하여 **DOM**을 생성한다.

사용자의 만족도를 높이기 위해 렌더링 엔진은 **HTML 문서가 모두 파싱될 때까지 기다리지 않고** 파싱 이후의 과정인 배치와 그리기를 미리 진행한다.

### 📌 Step 1-2. CSS 파싱 → CSSOM 트리 생성

HTML 파싱 중 CSS 문서를 가져오는 `link` 태그를 만나면, DOM 생성이 **잠시 중단**되고 해당 CSS의 파싱 과정이 시작된다.

CSS 파서는 서버에서 수신받은 CSS 문서를 파싱하여 **CSSOM 트리**를 생성한다.
참고로 CSS 파싱 과정은 기본적으로 HTML 파싱 과정과 동일하다.

- **CSS 파싱 과정**

  1. 서버에서 **바이트 형태**의 CSS 문서를 응답받는다.

  2. 지정된 인코딩 방식(UTF-8)에 따라 이를 **문자열**로 변환한다.

     ```html
     <meta charset="UTF-8">
     ```

  3. 변환된 문자열을 **토큰**으로 분해한다.

  4. 토큰을 내용에 따라 **객체(노드)**로 변환한다.

  5. 객체를 **트리 구조**로 구성하여 **CSSOM**을 생성한다.

CSSOM 트리의 노드는 DOM 트리 요소의 선택자에 맞춰 적용될 CSS 스타일 정보가 포함되어 있다.

### 📌 Step 1-3. JavaScript 파싱

HTML 파싱 과정에서 `script` 태그를 만나면, 렌더링 엔진은 DOM 생성을 **잠시 중지**하고 서버에서 해당 JavaScript 리소스를 브라우저 엔진으로부터 받아온다. 그리고 **JavaScript 엔진**에게 제어권을 넘겨준다.

JavaScript 엔진은 받아온 JS 리소스를 파싱하여 **AST (추상 구문 트리)** 를 생성하고
이를 바이트코드로 변환해 실행한다.

JavaScript 파싱이 종료되면 렌더링 엔진은 다시 제어권을 돌려받고 DOM 생성을 이어나간다.

만일 `script` 태그를 `body` 태그의 중간에 작성할 경우, HTML 파싱이 끝나지 않은 상태에서 JavaScript로 인해 DOM이 조작되어 에러가 발생할 위험이 생긴다.
따라서 `script` 태그는 반드시 `body` 태그 내부의 **최하단**에 위치해야 한다.

(혹은 `script` 태그에 `defer` 속성을 부여하는 방법도 있다.)

### 📌 Step 2. Render Tree 생성

HTML과 CSS의 파싱 과정이 모두 끝나면, 각각의 결과물인 DOM 트리와 CSSSOM 트리를 서로 **결합**하여 **랜더 트리 (Render Tree)**를 생성한다.

![img](https://velog.velcdn.com/images/sylagape1231/post/fccec1b3-01d9-4c68-8187-ca28b1c5074d/image.png)DOM 트리 + CSSSOM 트리 = 랜더 트리 (👉[사진 출처](https://velog.io/@moonshadow/CSSOM))

- **랜더 트리 생성 과정**
  1. `html` 태그와 `body` 태그를 처리하며 **랜더 트리 루트**를 구성한다.
  2. **DOM**의 최상위 노드부터 순회하면서 **화면에 보여지지 않는 노드**를 랜더 트리의 구성에서 제외한다.
  3. 화면에 보여지는 나머지 노드에 **CSSOM** 규칙을 찾아 일치하는 스타일을 적용한다.
     (`position`이나 `float`를 사용했을 경우, 실제 그려지는 위치로 랜더 객체가 이동한다.)





### 📌 Step 3. 레이아웃 (Layout)

![img](https://velog.velcdn.com/images/sylagape1231/post/d8b41a4f-8c00-4fa9-8375-055932a2452a/image.png)

랜더 트리 생성이 끝나면, 전체적인 웹 페이지 화면 안에서 렌더 트리 내 각 노드의 위치, 크기 (너비와 높이) 를 계산하고, 이를 화면에 배치하는 레이아웃 (Layout) 과정이 진행된다.

즉, 레이아웃은 **렌더 트리의 노드들을 화면에 배치하는 과정**이다.

이때 노드의 위치는 (x, y) 좌표계를 사용하는데, 랜더 트리의 루트부터 아래로 내려가면서 계산을 진행한다.

참고로 최상위 노드의 위치는 (0, 0)이며, CSS에서 상대적인 모든 값들은 절대적인 값인 `px` 단위로 변환된다.

레이아웃은 전체의 배치과정이 필요한 경우인 **글로벌 레이아웃**, 일부의 배치과정만 변경하면 되는 경우인 **로컬 레이아웃**으로 구분할 수 있다.

글로벌 레이아웃은 맨 처음에 레이아웃이 발생할 때, 그리고 초기 배치 이후 font와 같은 전역 스타일이 변경되거나 창이 리사이즈 될 때 발생한다. 초기 배치 이후 레이아웃 (Layout) 작업이 다시 일어나는 것을 **리플로우 (Reflow)**라 한다.

반대로 로컬 레이아웃은 초기 배치 이후 일부 DOM 노드에 변경이 생기는 것처럼, 특정 부분만 재배치가 필요할 때 발생한다. 이는 일부 변경만으로 전체 배치과정이 다시 일어나 불필요한 낭비가 발생하는 상황을 막아준다. 즉 로컬 레이아웃이 일어나는 경우는 모두 **리플로우**가 발생할 때이다.

(로컬 레이아웃은 **더티 비트 (Dirty Bit) 방식**이라는 것을 통해 진행된다.)

### 📌 Step 4. 페인트 (Paint)

마지막으로, 레이아웃 과정에서 계산된 정보들을 바탕으로 각 노드를 화면에 그려주는 페인트 (Paint) 과정이 진행된다. 페인트는 렌더 트리의 각 노드를 **화면의 실제 픽셀로 변환**해주는 작업이다. 픽셀로 변환하는 이 과정을 **래스터화 (Rasterizing)**라 부른다.

페인트 과정 중 화면의 특정 위치에 여러 개의 노드가 함께 그려지는 경우, 여러 레이어를 만들고 이를 다시 합성하는 방식으로 작업이 이루어진다.

페인트 과정이 끝나면 브라우저 화면에 네이버 페이지가 보여진다.

![img](https://velog.velcdn.com/images/sylagape1231/post/26b892d4-76f6-430e-adfc-f8c1ea62e9c3/image.png)

브라우저에 특정 변경이 생긴다면 이를 화면에 다시 그려주어야 하는데, 이렇게 페인트 과정이 다시 일어나는 것을 **리페인트 (Repaint)**라 한다. 기본적으로 리플로우가 발생하면 리페인트도 함께 발생한다. 또한 화면의 구조가 변하지 않더라도 요소의 색깔이 변한다면 리페인트가 일어난다.

브라우저는 변경 사항이 발생했을 때 최소한의 작업만으로 동작하려 한다는 걸 이해하는 것이 중요하다.