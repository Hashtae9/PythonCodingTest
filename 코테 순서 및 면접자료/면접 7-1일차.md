[TOC]



# 면접 7-1일차

## 1. 웹서버에 대해 설명해주세요 + 2. Was(웹 어플리케이션 서버)에 대해 설명해주세요

### Web Server

웹서버에 대해서는 이미 배포할 때 다뤄본 개념이다. ([개념](https://hazel-developer.tistory.com/66?category=817915), [설치 및 사용하기](https://hazel-developer.tistory.com/138?category=817915))

다시 정리 해보자면, 아래와 같은 한 문 장으로 Web server를 정의할 수 있다.

> 웹 브라우저 클라이언트로부터 HTTP 요청을 받아들이고 HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램

여기서 "HTML 문서와 같은 웹페이지" 라는 설명에 주목할 필요가 있다. 이 부분이 Web Server와 곧 설명할 WAS간의 개념적 차이와 관련이 있다. 그렇다면 Web Server(웹 서버)에 대해 좀 더 자세하게 설명해 보겠다.

 

웹 서버란 클라이언트가 브라우저에서 어떠한 요청을 하면, 그 요청을 받아서 **정적 컨텐츠를 제공하는 서버**이다. 웹서버는 웹에서 브라우저의 요청을 받아들여 처리하는 통신적 역할을 하지만 **정적 컨텐츠를 "제공"하는 서버**인 것이다.

그렇다면 동적 컨텐츠는? 웹 서버는 동적 컨텐츠에 대한 요청은 무시 하는 것일까? 그렇지 않다. **웹서버는 동적 컨텐츠에 대해서는 해당 요청을 받으면 WAS에 넘겨주고, WAS에서 이에 대해 처리한 결과를 클라이언트에게 전달하는 역할**을 한다.

 

태초에는(비유적 표현) 웹서버만이 존재했고, 이 때 클라이언트의 요청에 따라서 정적인 컨텐츠를 제공했을 것이다. 그런데 통신이 점점 복잡해지고, 동적이게 되면서 클라이언트의 요청에 대해 동적으로 "처리" 즉 계산하여 그 결과를 넘겨주는 행위가 필요했을 것이다.

내가 참고한 영상에서는 구구단을 비유로 들었는데, 이해가 잘 되어서 여기서도 예시로 언급해 보도록 하겠다.

만약에 웹서버로 정적인 컨텐츠만을 제공할 때, 구구단에 대한 요청을 처리하려면, 1X1 = 1 , 1X2 = 2 .... 이 모든 것을 다 하드코딩으로 일일이 입력해서 전달해야 한다. 그냥 프로그래밍 언어로 for 문을 돌리면 금방 처리할 수 있을 텐데 말이다.

그런데 **웹서버가 제공하는 정적 컨텐츠인 HTML은 프로그래밍 언어가 아니다.** 

 

따라서, 클라이언트의 요청 중, 동적인 요청 즉 프로그래밍 처리가 필요한 것에 대해서 처리를 해줄, 프로그래밍 언어가 탑재된(적절한 용어가 아닐수도있다 비유적으로 이해하자)웹서버가 필요했고, 이것이 WAS 이다.

 

#### 웹 서버 기능

**Http 프로토콜을 기반**으로, 클라이언트의 요청을 서비스하는 기능을 담당

- **정적 컨텐츠 제공: WAS를 거치지 않고 바로 자원 제공**
- **동적 컨텐츠 제공을 위한 요청 전달 : 클라이언트 요청을 WAS에 보내고, WAS에서 처리한 결과를 클라이언트에게 전달**

**웹 서버 종류** : Apache, Nginx, IIS 등

 

> 여기서 정적 콘텐츠와 동적 컨텐츠에 대해 정리해 보려 한다.
> 정적 콘텐츠(static)는 변화가 없는 콘텐츠를 말한다. 보통 HTML, CSS, JS와 같이 미리 서버에 저장해두고 서버가 요청을 받으면 그저 응답만 해주면 되는 것들로 구성되어 있다. 이것은 곧 어느 사용자에게든지 동일하게 결과값을 보여주게 된다.
> 동적 콘텐츠(dynamic)는 누가, 언제, 어떻게 서버에 요청했는지에 따라 결과값을 다르게 보여주는 형식이다. 즉, 사용자가 맞춤형 콘텐츠를 제공할 수 있게 되는 것이다. 예를 들면 유투브의 추천 영상이라던지, 이 콘텐츠를 제일 잘 활용하는 웹 서비스는 넷플릭스이다.



### WAS(Web Application Server)

위의 웹서버에 대한 설명에서 이제 WAS가 웹서버와 가지는 차이점을 유추할 수 있다. 

> "인터넷 상에서 HTTP 프로토콜을 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어로서, 주로 동적 서버 컨텐츠를 수행하는 것으로 웹 서버와 구별이 되며, 주로 데이터베이스 서버와 같이 수행"

즉 **WAS는 데이터베이스의 조회나 다양한 로직처리가 필요한 동적 컨텐츠를 제공**한다.(최근 대부분의 요청은 동적 컨텐츠라고 유추 가능할 것이다. 웹서버 뿐 아니라 WAS또한 필수적인 개념인 것이다.) 동적인 컨텐츠를 처리하고 제공한다는 의미에서, 웹서버와 가장 큰 차이점은 상황에 따라 변하는 정보를 제공할 수 있다고 정리할 수 있다. 실질적으로 **WAS는 웹서버와 웹컨테이너가 합쳐진 개념**이다.

 



![img](https://blog.kakaocdn.net/dn/OUrug/btqULCjK9Cc/F5ckXANQOCe350mWAk07S1/img.png)



**WAS는 웹 컨테이너 혹은 서블릿 컨테이너**라고도 불린다.

> 여기서 웹 컨테이너란 JSP, Servlet을 실행시킬 수 있는 소프트웨어. 즉, WAS는 JSP, Servlet 구동 환경을 제공해줌

####  WAS의 기능

- WAS = 웹 서버 + 웹 컨테이너
- 웹 서버의 기능들을 구조적으로 분리하여 처리하는 역할
- 보안, 스레드 처리, 분산 트랜잭션 등 분산 환경에서 사용됨 ( 주로 DB 서버와 함께 사용 )
- 프로그램 실행 환경 및 DB 접속 기능 제공
- 업무 처리하는 비즈니스 로직 수행
- 동적인 페이지를 생성할 수 있는 서버

**WAS 종류** : Tomcat, JBoss 등





### **Web Service Architecture**

웹 어플리케이션은 요청 처리 방식에 따라 다양한 구조를 가질 수 있다.

- 클라이언트(사용자) → Web Server → DB
- 클라이언트(사용자) → WAS → DB
- 클라이언트(사용자) → Web Server → WAS → DB



![img](https://blog.kakaocdn.net/dn/cCmFKd/btqUJXhog1b/VgGZjBBa2LAfkHf137PKaK/img.png)



 

**‼ [ 클라이언트(사용자) → Web Server → WAS → DB ] 구조의 동작 과정 \**‼\****

> 1. Web Server는 웹 브라우저 클라이언트(사용자)로부터 HTTP 요청을 받는다.
> 2. Web Server는 클라이언트의 요청(Request)을 WAS에 보낸다.
> 3. WAS는 관련된 Servlet을 메모리에 올린다.
> 4. WAS는 [web.xml을](https://codechasseur.tistory.com/web.xml을) 참조하여 해당 Servlet에 대한 Thread를 생성한다. (Thread Pool 이용)
> 5. HttpServletRequest와 HttpServletResponse 객체를 생성하여 Servlet에 전달한다.
>
> 5-1. Thread는 Servlet의 service() 메서드를 호출한다.
> 5-2. service() 메서드는 요청에 맞게 doGet() 또는 doPost() 메서드를 호출한다.
>
> 6. protected doGet(HttpServletRequest request, HttpServletResponse response)
> 7. doGet() 또는 doPost() 메서드는 인자에 맞게 생성된 적절한 동적 페이지를 Response 객체에 담아 WAS에 전달한다.
> 8. WAS는 Response 객체를 HttpResponse 형태로 바꾸어 Web Server에 전달한다.
> 9. 생성된 Thread를 종료하고, HttpServletRequest와 HttpServletResponse 객체를 제거한다.





## 3. Nginx에 대해 설명해주세요 + 4. Nginx와 Apache의 차이점에 대해 설명해주세요



### Apache HTTP Server

Apache는 Apache Software Foundation에서 만든 웹 서버 프로그램이다. 거의 모든 OS에서 실행되고, 다른 유명한 소프트웨어 프로젝트와의 문서화가 잘 되어있고 통합 지원 등의 이점이 있습니다.



### 주요 특징

스레드 / 프로세스 기반 구조
![img](https://velog.velcdn.com/images%2Fdeannn%2Fpost%2Fd47876a7-25a9-4ea3-adf5-46b3d5af59c5%2Fimage.png)

- **Apache는 클라이언트 요청당 하나의 스레드가 처리하는 구조**입니다.
- **사용자가 많으면 스레드 생성, 메모리 및 CPU 낭비가 심합**니다.



MPM (Multi-Process Module)

> MPM은 크게 두 가지 방식이 있습니다.
> `PreFork 방식` / `Worker 방식`

![img](https://velog.velcdn.com/images%2Fdeannn%2Fpost%2F0489b3cd-de07-4d01-9f6e-0ef06618e008%2Fimage.gif)



PreFork MPM (다중 프로세스)

- **Client 요청에 대해 Apache 자식 프로세스를 생성하여 처리**합니다.
- **요청이 많을 경우 Process를 생성하여 처리**합니다.
  이 방식은 Apache 설치 시 default로 설정되어 있습니다.
- 하나의 자식 프로세스 당 ***하나의 스레드*** 를 갖는 구조로, 자식 프로세스는 최대 1024개까지 가능합니다.
- **스레드 간 메모리 공유를 하지 않습**니다.
  이 방식은 독립적이기에 안정적인 반면, 메모리 소모가 크다는 단점이 있습니다.
- 실행 중인 프로세스를 복제하여 실행합니다. (메모리 영역까지 복제)
- 응답 프로세스를 미리 띄어놓고 클라이언트 요청 시 자식 프로세스가 반응하는 방식입니다.
- 디버깅이 빈약한 플랫폼에서 쉬운 디버깅이 가능합니다.
- 일반적으로 Single CPU 또는 Dual CPU에서 성능이 더 좋습니다.

![img](https://velog.velcdn.com/images%2Fdeannn%2Fpost%2F100ec186-c79c-4db6-821c-013576633321%2Fimage.gif)

- Worker MPM (멀티 프로세스-스레드)
  - **Prefork 보다 메모리 사용량이 적고, 동시 접속자가 많은 사이트에 적합**합니다.
    **각 프로세스의 스레드를 생성해 처리하는 구조**입니다.
  - **스레드 간의 메모리 공유가 가능**합니다.
  - 프로세스당 최대 64개의 스레드 처리가 가능하며, 각 스레드는 하나의 연결만을 부여받습니다.
  - 일반적으로 Multi CPU 시스템에서 성능이 좋습니다.



동적 컨텐츠 처리

다양한 모듈



### 단점

- **클라이언트 접속 시 마다 프로세스 또는 스레드를 생성하는 구조**이기에 **대량의 클라이언트(1만 이상)가 동시 접속한다면 CPU/메모리 사용이 증가하고 프로세스/스레드 생성 비용이 드는 등 요청에 한계**가 있습니다.
- Apache 서버의 프로세스가 blocking되면 요청을 처리하기 못하고 처리가 완료될 때 까지 계속 대기합니다.
  **Keep Alive**(접속 대기)를 이용해 해결이 가능하지만, Keep Alive 때문에 대량 접속 시 효율이 떨어짐





### NginX

Apache의 C10K 문제점 해결을 위해 만들어진 ***Event-Driven\*** 구조의 웹 서버 소프트웨어입니다. 즉, 프로그램의 흐름이 이벤트에 의해 결정되는 방식입니다.

> ***C10K** : 1만개의 클라이언트 문제*
>
> - 한 시스템에 동시 접속자 수가 1만명이 넘어갈 때 효율적 방안

### 주요 특징

Event-Driven 처리 기반 구조
![img](https://velog.velcdn.com/images%2Fdeannn%2Fpost%2Fb4a393fa-1330-4e5c-b20d-576337c8c844%2Fimage.png)

- **한 개 또는 고정된 프로세스만 생성**하고, 여러 개의 Connection을 모두 **Event-Handler를 통해 비동기 방식으로 처리**합니다.
- 적은 양의 스레드만 사용되기 때문에 **Context Swiching** 비용이 적고, CPU 소모가 적습니다.
- Apache와 달리 **동시 접속자 수가 많아져도 추가적인 생성 비용이 들지 않습니다.**
- CPU와 관계없이 **모든 I/O들을 전부 Event Listener로 미루기 때문에 흐름이 끊기지 않고 응답이 빠르게 진행되어 1개의 프로세스로 더 빠른 작업이 가능**합니다.
  이 덕분에 메모리를 적게 사용합니다.

> **Context Swiching**
>
> - Context: 스레드가 작업을 진행하는 동안 작업정보(레지스터, 커널스택, 사용자스택 등)를 보관.
> - OS가 A작업을 진행할 때 A스레드의 Context를 읽어오며, B스레드로 전환 할 때 A스레드의 Context를 저장하고 B스레드의 Context를 읽어오는 일련의 반복을 수행.
> - 스레드의 갯수가 많아질 수록 context swiching 작업은 더 빈번하게 일어나고, 이 때문에 성능이 저하될 수 있음.



리버스 프록시로 배치 가능

- NginX의 빠른 처리 속도를 활용하여 클라이언트의 모든 요청을 처리합니다.



### 단점

- **동적 컨텐츠를 기본적으로 처리할 수 없습니다.**
  외부 프로세서로 전달하고 렌더링 된 컨텐츠를 다시 전송할 때 까지 기다려야 합니다. (프로세스 속도 저하)
- Apache에 비해 다양한 모듈이 없습니다.



## 5. 프록시 서버란 무엇인가요? + 6. 포워드 프록시와 리버스 프록시에 대해 설명해주세요

### 프록시 서버 (Proxy Server)

프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해 주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.

서버와 클라이언트 사이에 중계기로서 대리로 통신을 수행하는 것을 가리켜 '프록시', 그 중계 기능을 하는 것을 프록시 서버라고 부른다.

프록시 서버 중 일부는 프록시 서버에 요청된 내용들을 캐시를 이용하여 저장해 둔다.

프록시는 크게 **Forward Proxy** 와 **Reverse Proxy** 로 나뉜다.



원래는 클라이언트가 서버에 직접 접근해서 요청한 내용을 가져와야 하지만

**프록시 서버가 대신 서버에 요청하고 클라이언트에게 가져다 줍**니다. 

예를 들면 클라이언트에서 naver의 주소를 입력해서 접속을 시도합니다.

이 요청은 서버로 가는게 아니라 프록시 서버로 갑니다. **프록시 서버가 네이버의 서버에 도착해서 웹페이지를 가져다가 클라이언트인 웹브라우저에게 보내주는거죠.**

프록시 proxy 에는 '대리' 라는 뜻이 있습니다. 클라이언트를 대리한다는 뜻 입니다. 중계인도 비슷한 말이죠.

![img](https://blog.kakaocdn.net/dn/dFN0rw/btqTxCzgbKH/cwTaS0DeIofMZVtqdt4se1/img.png)



![위키피디아 프록시 서버](https://blog.kakaocdn.net/dn/bpfOpn/btqTADLfdgs/r3NsKwniZYXswuSV8PRzd1/img.png)



### **프록시 서버의 대표적인 유형 세 가지**

1. HTTP 프록시: 이 프록시는 웹페이지에만 적합한 프록시입니다. HTTP 프록시로 브라우저를 설정하면 모든 브라우저 트래픽이 해당 경로를 통해 라우팅 됩니다.
2. SOCKS 프록시: 이 프록시는 웹페이지뿐만 아니라 응용프로그램에서도 사용할 수 있는 프록시입니다. SOCKS 프록시는 모든 종류의 트래픽을 처리할 수 있지만 보통 HTTP 프록시보다 연결 속도가 느리고 로딩 시간이 더 오래 걸립니다.
3. 투명 프록시: 투명 프록시(transparent proxy)는 위에서 설명한 프록시들과는 다른 유형의 프록시입니다. 사용자들이 투명 프록시를 사용하고 있다는 사실 자체를 모르는 경우가 많기 때문입니다. 일반적으로 투명 프록시는 회사나 부모가 기기 사용자의 온라인 활동을 모니터링하고 특정 웹사이트에 접근하지 못하도록 차단하고 싶은 경우에 사용되며 호텔과 카페는 투명 프록시를 통해 공용 와이파이에서 사용자를 인증하고 액세스 권한을 허용합니다.



### 프록시 서버를 사용하는 이유

**1. 개인정보를 보호할 수 있습니다.**



프록시 서버 없이 클라이언트가 네이버의 서버에 요청을 할 때 나의 IP 주소도 전달이 됩니다. 프록시 서버를 사용하면 네이버의 서버는 나의 IP가 아니라 프록시 서버의 IP를 보게 됩니다. 즉 네이버 서버 관리부에서는 IP 주소를 보고 어디서 네이버에 접속했는지 알아낼 수 있습니다. 프록시 서버를 사용하면 나의 IP주소는 네이버 서버에 전달되지 않습니다.

 

**2. 캐시 사용 - 속도향상**

 

**프록시 서버가 웹페이지를 가져올 때 자신의 데이터베이스에 최근 데이터를 저장**해놓습니다. 이것을 **캐시**라 합니다 (Cache)

**다른 클라이언트가 접속할 때 캐시된 웹페이지가 있으면 프록시 서버에서 바로 클라이언트에 전송함으로써 속도를 향상** 시킬 수 있습니다. 인터넷으로 갈 필요도 없이 프락시 서버에서 끝나는 것이죠.

프락시 서버에서는 **가비지 콜렉션을 해서 캐시 상태를 유지**합니다. 원본 문서에 대한 캐시도 업데이트하여 클라이언트에 문서의 최신 버전을 전달할 수 있도록 합니다.

캐시기능을 사용하면 인터넷으로 데이터를 수집하러 나갈 필요가 없으니까 대역폭을 줄이는 효과도 있습니다.

 

**3. 로그 기록 관리**

 

**서버에게 개인정보가 보호되지만 프록시 서버에는 클라이언트의 기록이 남아있습**니다.

이 기록들을 보면 어떤 IP에서 어디에 얼마나 오래 접속했는지 기록을 확인할 수 있습니다.

또 **프록시 서버가 방문할 수 있는 웹사이트를 제한**할 수 있습니다.

결국 **연결된 클라이언트들의 정보를 제어할 수 있기 때문에 프록시 서버는 회사에서 많이 사용**합니다.

관리자가 프록시 서버를 열어보면 직원들이 어떤 사이트에 접속했는지 손바닥 처럼 들여다 볼 수 있기 때문이죠.

 

**4. 방화벽**

 

프락시 서버와 방화벽은 다른 것이지만 보안을 위해 함께 일합니다.

프락시는 요청을 방화벽은 네트워크 패킷을 제어합니다.

 

**5. 접속 우회**

 

프록시 서버는 여러대 연결시킬 수 있습니다.

***클라이언트 -> 프락시 서버1 -> 프락시 서버2 -> 서버***

**클라이언트의 IP를 숨기기 위해 여러 프록시 서버를 경유하는 기술을 Proxy Chaining** 이라고 합니다.

흔히 **해커들의 IP주소를 숨기고 공격할 때 쓰는 수법**으로 알려져 있습니다만,

Proxy Chaining 이 완벽한 기술은 아닙니다. 어쨋든 서버에는 **프록시 서버의 주소가 남아있을테니 추적을 거듭하면 클라이언트를 알아낼 수도 있습니다. 다만 여러 국가의 컴퓨터에 접속해서 우회한다면 상당히 힘들겠죠? 나라마다 정보 보호법이 달라서 서버의 정보를 공개하지 않는 나라**도 있으니까요.

토르 브라우저 (Tor Browser)는 Tor Network 의 프록시 서버를 사용할 수 있도록 고안된 브라우저 입니다.

클라이언트를 특정할 수 없도록 중간에 Tor Network 의 컴퓨터들이 운영되고 있습니다.



## VPN이란?

[VPN](https://nordvpn.com/ko/download/)(Virtual Private Network, 가상 사설망)이란 프**록시 서버와 마찬가지로 원격 서버를 통해 인터넷 트래픽을 재라우팅하고 실제 [IP](https://nordvpn.com/ko/what-is-my-ip/) 주소를 가상 IP 주소로 대체함으로써 웹사이트 측에서 사용자의 실제 IP 주소와 위치를 확인할 수 없도록 합**니다.

하지만 프록시 서버와 달리 **VPN은 운영 체제 수준에서 동작하므로 브라우저나 백그라운드 앱에서 발생하는 모든 트래픽을 리디렉션할 수 있다는 차이점**이 있습니다.

VPN을 이용하면 [Windows](https://nordvpn.com/ko/blog/windows-vpn/), Chrome을 포함한 **다양한 플랫폼에서 인터넷과 기기 사이의 트래픽을 암호화**할 수 있으며 인터넷 업체가 사용자의 온라인 활동을 확인할 수 없도록 할 수 있습니다. 또한 **VPN을 사용하면 정부 감시를 회피하고 사이버 범죄와 해킹 공격을 방지**할 수 있으며 **프라이버시와 보안도 확보**할 수 있습니다.

다수의 VPN과 프록시 서비스가 IP 주소, DNS 요청과 같은 사용자의 중요 정보를 기록하고 있습니다. 또한 이러한 서비스 중 일부는 사용자의 중요 정보를 사법당국에 제공하거나, 광고 업체에 판매하는 경우가 있으며, 해킹으로 인해 정보가 유출되는 경우도 있습니다.

따라서 VPN을 선택할 때에는 [엄격한 노로그 정책](https://nordvpn.com/ko/features/strict-no-logs-policy/)을 준수하는 서비스를 이용해야 한다는 것을 기억해 주세요.



### Forward Proxy

**클라이언트(사용자)가 인터넷에 직접 접근하는게 아니라 포워드 프록시 서버가 요청을 받고 인터넷에 연결하여 결과를 클라이언트에 전달 (forward)** 해준다.

프록시 서버는 **Cache 를 사용하여 자주 사용하는 데이터라면 요청을 보내지 않고 캐시에서 가져올 수 있기 때문에 성능 향상이 가능**하다.

![img](https://github.com/ParkJiwoon/PrivateStudy/blob/master/images/forward-proxy.png?raw=true)

### Reverse Proxy

**클라이언트가 인터넷에 데이터를 요청하면 리버스 프록시가 이 요청을 받아 내부 서버에서 데이터를 받은 후 클라이언트에 전달**한다.

클라이언트는 **내부 서버에 대한 정보를 알 필요 없이 리버스 프록시에만 요청**하면 된다.

**내부 서버 (WAS) 에 직접적으로 접근한다면 DB 에 접근이 가능하기 때문에 중간에 리버스 프록시를 두고 클라이언트와 내부 서버 사이의 통신을 담당**한다.

또한 내부 서버에 대한 설정으로 **로드 밸런싱(Load Balancing) 이나 서버 확장 등에 유리**하다.

![img](https://github.com/ParkJiwoon/PrivateStudy/blob/master/images/reverse-proxy.png?raw=true)



# 차이점

**1. End Point**

Forward Proxy 는 클라이언트가 요청하는 End Point 가 **실제 서버 도메인**이고 프록시는 둘 사이의 통신을 담당해준다.

Reverse Proxy 는 클라이언트가 요청하는 End Point 가 **프록시 서버의 도메인**이고 실제 서버의 정보는 알 수 없다.

**2. 감춰지는 대상**

Forward Proxy 는 **클라이언트가 감춰진다.**

요청 받는 서버는 포워드 프록시 서버를 통해서 요청을 받기 때문에 클라이언트의 정보를 알 수 없다.

Reverse Proxy 는 반대로 **서버가 감춰진다.**

클라이언트는 리버스 프록시 서버에게 요청하기 때문에 실제 서버의 정보를 알 수가 없다.