[TOC]





# 면접 5일차

## 1. 데이터베이스 무결성 3가지에 대해 설명해주세요

### 데이터 무결성

+ 데이터베이스에 저장된 데이터의 **`정확성`**, **`일관성`**, **`유효성`**을 지키는 것
+ 제약조건으로 데이터베이스 시스템이 강제



### 데이터 무결성 제약조건

+ **`데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건`**
  + 데이터의 무결성을 보장하고, 데이터베이스의 상태를 일관되게 유지하는 것이 목표



### 무결성 제약조건의 종류

👉 **`개체 무결성`**

**모든 테이블은 기본키**를 가져야 하며, 기본키를 구성하는 속성으로 Null과 Unique Key가 있다. 각각 **Null값이나 중복된 값을 가질 수 없다는 뜻**이다.

👉 **`참조 무결성`**

참조 관계에 있는 **두 테이블의 데이터가 항상 일관된 값을 갖도록 유지**되어야 한다. 다시 말해, **외래키 값은 Null이거나 참조하는 테이블의 기본키값과 동일**해야 한다.

👉 **`도메인 무결성`**

**테이블에 존재하는 필드의 무결성을 보장**해야 하는 것으로, 데이터의 타입에 맞아야 한다. 예를 들어 '성별'이라는 속성에서 '남', '여'를 제외한 데이터를 제한되어야 한다.

👉 **`NULL 무결성`**

테이블의 특정 속성 값을 **Null이 될 수 없도록 제한했다면 해당 속성에 Null이 있으면 안된다**.

👉 **`고유 무결성`**

**테이블의 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 각 레코드가 가지는 값들이 달라야 한다**. 예를 들어, '이름, '나이'는 서로 같은 값이 있을 수 있지만, '학번'의 경우, 서로 다른 값을 가져야 한다.



## 2. 관계형 데이터베이스와 비관계형 데이터베이스에 대해 설명해주세요

### 관계형 데이터베이스

+ 관계형 데이터베이스란 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타냄
+ 테이블은 이름을 가지고 있으며, 행(row)과 열(column) 그리고 거기에 대응하는 값을 가짐
+ 관계형 데이터베이스는 위와 같이 구성된 테이블이 다른 테이블들과 관계를 맺고 모여있는 집합체로 이해
  + 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스



#### 특징

+ 데이터의 분류, 정렬, 탐색 속도가 빠름
+ 오랫동안 사용된 만큼 신뢰성이 높고, 어떤 상황에서도 데이터의 무결성을 보장
+ 기존에 작성된 스키마를 수정하기가 어렵다
+ 데이터베이스의 부하를 분석하는 것이 어렵다



### 비관계형 데이터베이스

+ NoSQL이라고도 부르며, Not Only SQL(SQL 뿐만이 아닌. 이라는 뜻)의 줄임말
+ 관계형 데이터베이스보다 더 융통성 있는 데이터 모델을 사용하며, 데이터의 저장 및 검색에 특화된 메커니즘을 제공
+ 분산 환경에서의 데이터 처리를 더욱 빠르게 하기 위해 개발
+ 거대한 Map으로서 key-value 형식을 지원함.
+ 관계형 db와 달리 PK, FK JOIN등 관계를 정의하지 않음.
+ 스키마에 대한 정의가 없다.



#### 특징

+ 대용량 데이터 처리를 하는데 효율적임.
+ 읽기 작업보다 쓰기 작업이 더 빠르고 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 빠름.
+ 데이터 모델링이 유연함.
+ 뛰어난 확장성으로 검색에 유리함.
+ 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어남.
+ 복잡한 데이터 구조를 표현할 수 있음
+ 쿼리 처리시 데이터를 파싱 후 연산을 해야해서 큰 크기의 document를 다룰 때는 성능이 저하됨.



## 3. 트랜잭션에 대해 설명해주세요 + 4. 트랜잭션 ACID에 대해 설명해주세요 + 5. 트랜잭션 고립성 수준에 대해 설명해주세요 + 6. **Non-repeatable read와 Phantom Read의 차이점에 대해 설명해주세요.**

### 트랜잭션

+ 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행되어야할 일련의 연산들을 의미

+ 작업의 완전성을 보장

  + 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능

+ SELECT, UPDATE, INSERT, DELETE와 같은 연산을 수행하여 데이터베이스의 상태를 변화시키는 작업의 단위

+ **트랜잭션의 범위를 최소화하는 것이 좋음**

  + 일반적으로 데이터베이스 커넥션은 개수가 제한적이다.

    그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다.



### 트랜잭션의 특징(ACID)

+ **Atomicity(원자성)**
  - 트랜잭션이 **데이터베이스에 모두 반영되던지, 아니면 전혀 반영 되지 않아야 한다.**
  - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

+ **Consistency(일관성)**
  - **트랜잭션의 작업 처리 결과가 항상 일관성**이 있어야 한다.
  - 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 수행 완료 후의 상태가 같아야 한다.
+ **Isolation(독립성)**
  - **둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들수 없다.**
  - 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조 할 수 없다.
+ **Durability(지속성)**
  - **트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영**되어야 한다.



### 트랜잭션의 Commit과 Rollback

+ **Commit**
  + commit 연산은 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때 하나의 트랜잭션이 끝났음을 알려주기 위해 사용하는 연산
+ **Rollback**
  +  하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산



### 트랜잭션의 상태

<img src="https://user-images.githubusercontent.com/101400894/218033448-741624bb-765a-4cb5-a847-3a2406fe716f.png" alt="image" style="zoom:100%;" align="left"/>

+ 활동(Active) : 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.
+ 부분완료(Partially Committed) : 트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit 이전 sql문이 수행되고 commit만 남은 상태를 말한다.
+ 완료(Committed) : 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.
+ 실패(Failed) : 트랜잭션 실패 상태. 트랜잭션이 더 이상 정상적으로 진행될 수 없는 상태를 말한다.
+ 취소(Aborted) : 트랜잭션 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.



💎**부분완료와 완료의 차이점**

**commit요청이 들어오면 상태는 부분완료 상태**가 된다. 이후 **commit을 문제없이 수행 할 수 있다면 완료 상태**로 전이되고, 만약 **오류가 발생하면 실패 상태**가 된다. 즉, **부분완료는 commit요청이 들어왔을 때**를 말하며, **완료 상태는 commit을 정상적으로 완료한 상태**를 말한다.



### 트랜잭션의 병행제어, 로킹, 타임스탬프

[주소](https://rebro.kr/163)



### 트랜잭션의 고립화 수준

+ **트랜잭션의 독립성, 고립성을 유지하기 위해 데이터에 대한 접근을 허용하는 수준**
+ 로킹(Locking) 기술을 기반으로 고립화 수준을 조정하며 총 4개의 레벨로 구성



#### 고립화 수준에 따른 문제점

**1) 부정 판독(Dirty Read)**

+ 부정 판독은 **다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것**을 말한다.

+ 트랜잭션 T1이 특정 데이터를 갱신한 후 T2가 해당 데이터를 읽은 다음 T1이 Rollback 되면 T2는 존재하지 않은 값을 가리키게 되는 비일관된 상태에 놓이게 된다. 

 

**2) 비반복 판독(Non-repeatable Read)**

+ 비반복 판독은 **한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 중간에 다른 트랜잭션이 값을 갱신하거나 삭제함으로써 읽은 값이 서로 다르게 되는 현상**이다. 



**3) 팬텀 판독(Phantom Read)** 

+ 팬텀 판독은 **한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 중간에 다른 트랜잭션이 값을 추가함으로써 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상**이다. 

 

💎한 트랜잭션 내에서 같은 쿼리를 두 번 실행했을 때...

- **Non-Repeatable Read** : 조회된 record의 값이 다른 경우
- **Phantom Read **: 없던 record가 생기거나, 있던 record가 사라지는 경우.

즉 **non-repeatable read는 "한 레코드의 값"에 초점**이 맞춰져있고, **phantom read는 "레코드의 존재 유무"**에 초점이 맞춰져 있는 것이다.

Non-Repeatable Read의 경우 트랜잭션 ID를 부여해 자신의 버전보다 낮은 버전의 데이터만 읽는 Repeatable Read 격리수준에서는 발생하지 않는다. 다른 트랜잭션이 수정사항을 커밋하더라도 그 트랜잭션이 자신보다 늦게 생긴 트랜잭션이면 해당 변경사항을 반영하지 않기 때문이다.

phantom read는 일반적으로 Repeatable Read 이하의 격리수준에서 발생할 수 있다. 그러나 MySQL의 InnoDB의 경우 갭 락과 넥스트 키 락 덕분에 repeatable read에서도 phantom read가 발생하지 않는다(잠금을 동반한 SELECT에서는 발생한다).





#### **고립화 수준(Isolation Level)의 유형**

<img src="https://user-images.githubusercontent.com/101400894/218034315-c0ef6d84-5aa6-48df-bcd5-7a6edb6038f2.png" alt="image" style="zoom:80%;" align='left'/>

**1. Read uncommitted (Level 0)**

+ **트랜잭션에서 아직 commit 되지 않고 처리 중인 데이터를 다른 트랜잭션이 읽을 수 있다.**
+ 부정 판독, 비반복 판독, 팬텀 판독 모두 발생하는 레벨이다. 
+ SELECT문을 수행하는 경우 해당 데이터에 Shared Lock이 걸리지 않는 레벨이다. 



**2. Read committed (Level 1)**

+ **트랜잭션이 commit 된 데이터만 다른 트랜잭션이 읽을 수 있다.** 따라서 부정 판독(Dirty Read)을 방지해준다.
+ 대부분의 DBMS에서 기본으로 채택하는 레벨이다. 

 

**3. Repeatable Read (Level 2)**

+ **선행 트랜잭션이 데이터를 읽는 경우 종료 전까지 다른 트랜잭션의 갱신/삭제가 불가능하다.** 같은 레코드의 반복적인 판독은 동일한 값으로 반환된다. 따라서 비반복 판독(Non-repeatable Read)을 방지해준다. 

 

**4. Serializable (Level 3)**

+ **선행 트랜잭션이 데이터를 읽는 경우 종료 전까지 다른 트랜잭션의 갱신/삭제/삽입이 불가능하다.** 따라서 새로운 레코드가 도중에 나타나지 않으므로 팬텀 판독(Phantom Read)을 방지해준다. 완벽한 정합성을 보장하는 레벨이다. 



### 트랜잭션의 회복 기법

+  **트랜잭션이 실행되는 동안 발생한 오류로부터 가장 가까운 정상 상태로 복귀하는 것**
+ **Undo** : 트랜잭션 로그를 이용하여 오류와 관련된 모든 변경을 취소하여 복구 수행
+ **Redo** : 트랜잭션 로그를 이용하여 오류가 발생한 트랜잭션을 재실행하여 복구 수행



#### 1. 로그 기반 회복

+ **지연 갱신 회복**
  + <img src="https://user-images.githubusercontent.com/101400894/218035328-84687ee0-9636-498f-9071-f4bd93927ee0.png" alt="image" style="zoom:80%;" />
  + 트랜잭션이 부분 완료 상태에 이르기까지 발생한 **모든 변경 내용을 로그 파일에만 저장하고 데이터베이스에는 커밋이 발생할 때까지 저장을 지연하는 방식**이다. 
  + 따라서 중간에 장애가 발생하더라도 데이터베이스에 아직 기록되지 않았기 때문에 **Undo 과정이 필요 없다**.
+ **즉시 갱신 회복**
  + 트랜잭션 수행 도중에 발생한 변경 내용을 로그 파일에 저장하고, 모든 변경 내용을 즉시 데이터베이스에 반영하는 방식
  + 트랜잭션 완료 이전에 수행된 갱신은 미완료 갱신이라고 하며, 회복하는 경우 Undo와 Redo를 모두 수행



#### 2. **검사점 기반 회복**

+ 장애가 발생한 경우 검사점 이전에 처리된 트랜잭션은 제외하고 검사점 이후에 처리된 트랜잭션에 대해서만 회복 작업을 진행하는 방식
+ <img src="https://user-images.githubusercontent.com/101400894/218035595-39fe0be4-c8e4-4805-afa1-9fb5409fc7f1.png" alt="image" style="zoom:80%;" />

+ 장애 이전의 가장 최근 검사점인 Checkpoint 2 이전의 트랜잭션 T1, T2, T3은 회복 작업에서 제외
+ 검사점 이후, 장애 발생 이전에 commit이 완료된 트랜잭션(T4, T5)은 Undo, 장애 발생 시점까지 commit 되지 못한 트랜잭션(T6)은 Redo를 수행



#### 3. **그림자 페이징 회복**

+ 그림자 페이징 회복은 현재 테이블은 주기억 장치, 그림자 페이지 테이블은 디스크에 저장하여 트랜잭션이 성공적으로 수행되는 경우 그림자 페이지 테이블을 삭제하고, 실패할 경우 그림자 페이지 테이블을 통해서 복구하는 방식이다. 
+ **트랜잭션이 시작될 때 현재 테이블과 동일한 그림자 테이블을 생성**한다. 



## 7. DB인덱스 설정 시 고려해야할 점을 설명해주세요. 성별과 주민등록번호 중에 어떤 것을 인덱스로 해야할까요? 그 이유는?

### DB index

+ 인덱스(`INDEX`)란 검색 속도를 높이기 위한 색인 기술
+ `SELECT` 쿼리의 `WHERE`에 사용할 컬럼에 대해 효율적인 검색을 위해 사용하거나, 다른 테이블과의 `JOIN`에 사용
+ SQL 서버에 데이터를 저장할 때는 내부적으로 아무런 순서없이 저장한다. (이때, 데이터 저장영역은 `Heap`)

+ `Heap`에서는 인덱스가 없는 테이블의 데이터를 찾을 때 전체 데이터 페이지의 처음 레코드부터 끝 페이지 마지막 레코드까지 모두 조회
  + 풀 스캔(Full Scan) ` 또는 ` 테이블 스캔(Table Scan)이라 함



### DB Index Example

```
-- t_student 테이블 SCHEMA
CREATE TABLE t_student (
  seq_no INTEGER PRIMARY KEY, -- sequence
  id CHAR(14) NOT NULL, -- 주민번호
  name VARCHAR(255) NOT NULL, -- 학생 이름
  age INTEGER NOT NULL, -- 나이
  grade INTEGER NOT NULL, -- 학년
  ins_timestamp     TIMESTAMP      NOT NULL -- 가입 일시
)


-- single column index for id
CREATE INDEX si_id ON t_student (id);
-- single column index for name
CREATE INDEX si_name ON t_student (name);
-- multi column index for id, name
CREATE INDEX mi_id_name ON t_student (id, name);
-- multi column index for id, name, age
CREATE INDEX mi_id_name_age ON t_student (id, name, age);
...
```

+ **무조건 많이 인덱스를 설정한다고 해서 검색 속도를 향상시켜주지는 않습니다.**



### Index 설정 기준

+ **카디널리티 (Cardinality)**
  **카디널리티가 높으면(↑) 인덱스 설정에 좋은 컬럼이다. (인덱스를 통해 불필요한 데이터의 대부분을 걸러낼 수 있음.)**
  카디널리티가 높다 = 한 컬럼이 갖고 있는 값의 중복도가 낮음. (= 값들이 대부분 다른 값을 가짐.)
  카디널리티가 낮다 = 한 컬럼이 갖고 있는 값의 중복도가 높음. (= 값들이 거의 같은 값을 가짐 )

+ **선택도 (Selectivity)**
  **선택도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다. (일반적으로 5~10%가 적당함.)**
  선택도가 높다 = 한 컬럼이 갖고 있는 값 하나로 여러 row가 찾아진다.
  선택도가 낮다 = 한 컬럼이 갖고 있는 값 하나로 적은 row가 찾아진다.

  > **선택도 계산법** (= 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100)
  > ex) 10개의 데이터에서 고유한 학번(grade) 컬럼, 2명씩 같은 이름(name) 컬럼, 5명씩 같은 나이(age) 컬럼인 경우
  > ① 학번(grade) 컬럼 선택도: 1 / 10 = 10%
  > ② 이름(name) 컬럼 선택도: 2 / 10 = 20%
  > ③ 나이(age) 컬럼 선택도: 5 / 10 = 50%

+ **조회 활용도**
  **조회 활용도가 높으면(↑) 인덱스 설정에 좋은 컬럼이다.**
  해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값.
  (`WHERE`의 대상 컬럼으로 많이 활용되는지로 판단하면 된다.)

+ **수정 빈도**
  **수정 빈도가 낮으면(↓) 인덱스 설정에 좋은 컬럼이다.**
  인덱스도 테이블이기 때문에, 인덱스로 지정된 컬럼의 값이 바뀌게 되면 인덱스 테이블도 새롭게 갱신되어야 하기 때문.



### Index를 무조건 많이 설정하면 안되는 이유가 무엇일까?

① 인덱스 설정 시, 데이터베이스에 할당된 메모리를 사용하여 테이블 형태로 저장되게 됩니다.
(즉, 인덱스가 많아지면 데이터베이스의 메모리를 많이 잡아먹게 됩니다.)
② 인덱스로 지정된 컬럼의 값이 바뀌게 되면 인덱스 테이블이 갱신되어야 하므로 느려질 수 있습니다.



### 설정된 Index가 DML(Data Manipulation Language)에 미치는 영향

+ **Select**
  성능이 매우 잘 나옴
+ **UPDATE, DELETE**
  **인덱스로 설정된 컬럼에 대해 조건(`WHERE`)을 사용할 수도 있는 `UPDATE`, `DELETE`사용 시 조회에서는 성능이 크게 저하되지 않는다.**
  **※ 여기서 수정/삭제할 데이터를 찾는 때의 속도가 빠르다는 것이지 수정이나 삭제 그 자체를 빠르게 처리한다는 뜻은 아니다.**
+ **INSERT**
  **반면, `INSERT`의 경우에는 효율이 좋지 않다.**
  새로운 데이터를 추가하면서 인덱스가 설정되어 있던 컬럼의 테이블이 수정되어야 하기 때문이다.



## 8. SQL 인젝션 공격에 대해 설명해주세요 + 9. SQL인젝션 공격을 막는 방법 중 하나인 prepared statement에 대해 설명해주세요

### SQL 인젝션

+ 악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위



### SQL 인젝션 공격 종류 및 방법

#### 1. **Error based SQL Injection**

+ **논리적 에러를 이용한 SQL Injection** 
+ SQL 공격 기법은 여러 가지가 있는데 논리적 에러를 이용한 SQL Injection은 가장 많이 쓰이고, 대중적인 공격 기법

<img src="https://user-images.githubusercontent.com/101400894/218045734-f0f29bd2-caa2-4965-939d-f99f370cb326.png" alt="image" style="zoom:60%;" ALIGN="LEFT"/>

+  ‘ OR 1=1 -- 로 WHERE 절에 있는 싱글쿼터를 닫아주기 위한 싱글쿼터와 OR 1=1 라는 구문을 이용해 WHERE 절을 모두 참으로 만들고, -- 를 넣어줌으로 뒤의 구문을 모두 주석 처리
+ Users 테이블에 있는 모든 정보를 조회하게 됨으로 써 가장 먼저 만들어진 계정으로 로그인에 성공하게 됩니다. 보통은 관리자 계정을 맨 처음 만들기 때문에 관리자 계정에 로그인 



#### 2. **Union based SQL Injection**

+ **Union 명령어를 이용한 SQL Injection**
  + SQL 에서 Union 키워드는 두 개의 쿼리문에 대한 결과를 통합해서 하나의 테이블로 보여주게 하는 키워드
  + 정상적인 쿼리문에 Union 키워드를 사용하여 인젝션에 성공하면, 원하는 쿼리문을 실행

<img src="https://user-images.githubusercontent.com/101400894/218046462-d6a2969e-c02c-411e-8a1c-8b2279f3d8e0.png" alt="image" style="zoom:60%;" ALIGN="LEFT"/>

+ Board 라는 테이블에서 게시글을 검색하는 쿼리문
+ 입력값을 title 과 contents 컬럼의 데이터랑 비교한 뒤 비슷한 글자가 있는 게시글을 출력
+ 입력값으로 Union 키워드와 함께 컬럼 수를 맞춰서 SELECT 구문을 넣어주게 되면 두 쿼리문이 합쳐서서 하나의 테이블로 보여지게 됩니다
+ 현재 인젝션 한 구문은 사용자의 id와 passwd를 요청하는 쿼리문 입니다. 인젝션이 성공하게 되면, 사용자의 개인정보가 게시글과 함께 화면에 보여지게 됨



#### 3. **Blind SQL Injection**

+ **Boolean based SQL**
  + 데이터베이스로부터 특정한 값이나 데이터를 전달받지 않고, 단순히 참과 거짓의 정보만 알 수 있을 때 사용
  + 로그인 폼에 SQL Injection이 가능하다고 가정 했을 때, 서버가 응답하는 로그인 성공과 로그인 실패 메시지를 이용하여, DB의 테이블 정보 등을 추출

<img src="https://user-images.githubusercontent.com/101400894/218046949-895b2d08-677e-45e3-87c3-38195e4c4fa0.png" alt="image" style="zoom:60%;" ALIGN="LEFT"/>

+ (MySQL) 인젝션이 가능한 로그인 폼을 통하여 악의적인 사용자는 임의로 가입한 abc123 이라는 아이디와 함께 abc123’ and ASCII(SUBSTR(SELECT name From information_schema.tables WHERE table_type=’base table’ limit 0,1)1,1)) > 100 -- 이라는 구문을 주입
  + 해당구문은 MySQL 에서 테이블 명을 조회하는 구문으로 limit 키워드를 통해 하나의 테이블만 조회하고, SUBSTR 함수로 첫 글자만, 그리고 마지막으로 ASCII 를 통해서 ascii 값으로 변환
  + 만약에 조회되는 테이블 명이 Users 라면 ‘U’ 자가 ascii 값으로 조회가 될 것이고, 뒤의 100 이라는 숫자 값과 비교
  + 거짓이면 로그인 실패가 될 것이고, 참이 될 때까지 뒤의 100이라는 숫자를 변경해 가면서 비교
  + 자동화 스크립트를 통하여 단기간 내에 테이블 명을 알아낼 수 있음



#### 4. **Blind SQL Injection**

+ **Time based SQL**
  + 서버로부터 특정한 응답 대신에 참 혹은 거짓의 응답을 통해서 데이터베이스의 정보를 유추하는 기법
  + 사용되는 함수는 MySQL 기준으로 SLEEP 과 BENCHMARK

<img src="https://user-images.githubusercontent.com/101400894/218047526-6a923f60-59d9-478b-839d-2b3243463bfa.png" alt="image" style="zoom:60%;" ALIGN="LEFT"/>

+ abc123’ OR (LENGTH(DATABASE())=1 AND SLEEP(2)) – 이라는 구문을 주입
+ 여기서 LENGTH 함수는 문자열의 길이를 반환하고, DATABASE 함수는 데이터베이스의 이름을 반환



#### 5. **Stored Procedure SQL Injection**

+ **저장된 프로시저 에서의 SQL Injection**
  + 저장 프로시저(Stored Procedure) 은 일련의 쿼리들을 모아 하나의 함수처럼 사용하기 위한 것
+ MS-SQL 에 있는 xp_cmdshell로 윈도우 명령어를 사용할 수 있게 됩니다. 단, 공격자가 시스템 권한을 획득 해야 하므로 공격난이도가 높으나 공격에 성공한다면, 서버에 직접적인 피해를 입힐 수 있는 공격



#### 6. **Mass SQL Injection**

+ **다량의 SQL Injection 공격**
  + 한번의 공격으로 다량의 데이터베이스가 조작되어 큰 피해를 입히는 것을 의미
+ MS-SQL을 사용하는 ASP 기반 웹 애플리케이션에서 많이 사용되며, 쿼리문은 HEX 인코딩 방식으로 인코딩 하여 공격
+  데이터베이스 값을 변조하여 데이터베이스에 악성스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비PC로 감염되게 합니다. 이렇게 감염된 좀비 PC들은 DDoS 공격에 사용



### 대응 방안

#### 1. **입력 값에 대한 검증**

+ 서버 단에서 화이트리스트 기반으로 검증
+ 블랙리스트 기반으로 검증하게 되면 수많은 차단리스트를 등록해야 하고, 하나라도 빠지면 공격에 성공하게 되기 때문입니다. 공백으로 치환하는 방법도 많이 쓰이는데, 이 방법도 취약한 방법



#### 2. **Prepared Statement 구문사용**

+ 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에DBMS가 미리 컴파일 하여 실행하지 않고 대기
+ 사용자의 입력 값을 문자열로 인식하게 하여 공격쿼리가 들어간다고 하더라도, 사용자의 입력은 이미 의미 없는 단순 문자열 이기 때문에 전체 쿼리문도 공격자의 의도대로 작동하지 않음



#### 3. **Error Message 노출 금지**

+ 공격자가 SQL Injection을 수행하기 위해서는 데이터베이스의 정보(테이블명, 컬럼명 등)가 필요합니다. 데이터베이스 에러 발생 시 따로 처리를 해주지 않았다면, 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환헤 줍니다. 여기서 테이블명 및 컬럼명 그리고 쿼리문이 노출이 될 수 있기 때문에, 데이터 베이스에 대한 오류발생 시 사용자에게 보여줄 수 있는 페이지를 제작 혹은 메시지박스를 띄우도록 하여야 합니다.



#### 4. **웹 방화벽 사용**

+ 웹 방화벽은 소프트웨어 형, 하드웨어 형, 프록시 형 이렇게 세가지 종류로 나눌 수 있는데 소프트웨어 형은 서버 내에 직접 설치하는 방법이고, 하드웨어 형은 네트워크 상에서 서버 앞 단에 직접 하드웨어 장비로 구성하는 것이며 마지막으로 프록시 형은 DNS 서버 주소를 웹 방화벽으로 바꾸고 서버로 가는 트래픽이 웹 방화벽을 먼저 거치도록 하는 방법



## 10. 파이썬은 이것으로 간단하게 sql 인젝션 공격을 막을 수 있습니다. 이것은 무엇일까요?

### %()s . . . 그럼 정수형은?

파이썬에서 `%s`는 문자형을 받을때 사용하고 정수는 `%d`로 받는다.
그럼 DB에서 컬럼이 int 타입일 때, Injection 대응코드도 `%(변수명)d` 혹은 `%d`로 되어야하는거 아닌가?

관련 문서를 찾지못해 직접 확인한 결과 다음과 같이 알 수 있었다.

결과 : 똑같이 문자형으로 넘겨주면 된다.

1. DB에서 컬럼이 int 타입이라도 인자값은 **문자형으로 만들어서 넘긴다.** 즉, **Argument 부터 정수라면 문자열로 형변환해서 넘긴다.**
2. 그것을 `%()s`로 받아주면 된다.



### 테이블에 null값이 되도록 해야할 경우

update나 insert시 전달받은 인자값이 공백(‘‘)일 때, 테이블에는 부득이하게 null을 넣고자할 경우.



## 11. DB 정규화 + 12. 정규화의 목적은 무엇인가요?

### 정규화

+ 테이블 간에 중복된 데이타를 허용하지 않는다는 것

+ 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있음



### 정규화의 목적

+ 불필요한 데이터(data redundancy)를 제거해 **불필요한 중복을 최소화**
+ 삽입/갱신/삭제 시 발생할 수 있는 **각종 이상 현상(Anomaly) 을 방지하기 위해서**, 테이블의 구성을 논리적이고 직관적으로 한다.



#### [ 제1 정규화 ]

제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것



#### [ 제2 정규화 ]

제2 정규화란 제1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것이다. 

여기서 완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미

즉, 기본키가 2개인 경우(복합키인 경우), 컬럼이 2개의 키에 의해 결정되어야 함

+ 복합키인데 부분집합의 키에 의해 컬럼값이 결정되면 안됨(분리할 필요가 있음)

+ 예시
  + (학생번호, 강좌이름) - 복합키
  + 성적 = 학생번호와 강좌이름이 합쳐져야 컬럼이 결정
  + 강의실 = 부분집합인 강좌이름만 있어도 결정됨(분리해야 함)



#### [ 제3 정규화 ]

제3 정규화란 제2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해하는 것이다. 

여기서 이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미

+ 한 테이블 내에서
+ 학생번호 => 강좌이름 => 수강료 의 경우
+ (학생번호, 강좌이름), (강좌이름, 수강료) 테이블로 나눠야함



#### [ BCNF 정규화 ]

BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것