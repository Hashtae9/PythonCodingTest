 ## 1.데드락이란 무엇인가요? + 2. 데드락의 발생 조건을 말해주세요 + 3.데드락 회피기법 중 은행원 알고리즘에 대해 말해주세요
### 데드락(Deadlock)
+ 시스템 자원에 대한 요구가 뒤엉킨 상태
+ **둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황**
<br>
### 데드락(Deadlock)의 발생조건
+ **상호 배제**
	+  **한 번에 프로세스 하나만 해당 자원을 사용할 수 있다**. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
-   **점유 대기**
	+ 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
-   **비선점**
	+ 이미 할당된 자원을 강제로 빼앗을 수 없다(비선점).
-   **순환 대기**
	+ 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.
<br>
### 데드락 해결법
#### 1. 데드락이 발생하지 않도록 **예방**(prevention) 하기
**데드락의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것**이 데드락을 예방하는 방법입니다. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단합니다.
<br>
-   **자원의 상호 배제 조건** 방지
	- **한 번에 여러 프로세스가 공유 자원을 사용**할 수 있게 합니다.
	+ 그러나 추후 **동기화 관련 문제가 발생**할 수 있습니다.
-   **점유 대기 조건 방지**
	- 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 합니다.
-   **비선점 조건 방지**
	- 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 합니다.
-   **순환 대기 조건 방지**
	- 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 합니다.
<br>
이러한 조건을 방지해서 데드락을 예방하는 방법은 **시스템의 처리량이나 효율성을 떨어트리는 단점**이 발생할 수 있습니다.
<br>
#### 데드락 발생 가능성을 인정하면서도 적절하게 **회피**(avoidance) 하기
> **Safe sequence, Safe state**
- 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 **안정 상태**(safe state)에 있다고 말합니다.

그리고 이처럼 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 **데드락이 발생하지 않는 순서를 찾을 수 있다면**, 그것을 **안전 순서**(safe sequence)라고 부릅니다.
<br>
반면 **불안정 상태**는 안정 상태가 아닌 상황을 말합니다. 즉, **데드락 발생 가능성이 있는 상황**이며, **교착 상태(데드락)는 불안정 상태일 때 발생**할 수 있습니다. 불안정 상태가 교착 상태보다 좀 더 큰 집합입니다.(즉, 교착 상태가 불안정 상태의 부분집합)
<br>
이처럼 회피 알고리즘은 **자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용**하자는 것이 기본 특징입니다.
<br>
이러한 특징을 살린 알고리즘으로 유명한 것이 `은행원 알고리즘` 입니다
<br>
#### 은행원 알고리즘 **(Banker’s Algorithm)**
<br>
다익스트라가 제안한 기법으로, 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, **미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부**를 검사합니다. 즉 대기중인 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 것입니다.
<br>
어떤 자원 한 가지에 대해서 은행원 알고리즘을 시뮬레이션 해보고자 합니다.

**처음에 시스템이 총 12개의 자원을 가지고 있다고 가정**해 보겠습니다.
<br>
![스크린샷 2023-05-15 오후 8 42 59](https://github.com/Hashtae9/RefrigeatorManager/assets/101400894/c6b59d64-aad4-4b38-ba59-682893056c64)
<br>
P0~P2는 프로세스이고, `Max`는 각 프로세스마다 최대 자원 요청량, `Allocation`은 현재 프로세스에 할당 중인 자원의 양, `Need`는 남은 필요한 자원의 양(Max-Allocation) 입니다.

현재 t0일 때 **프로세스에 할당된 자원의 합은 5+2+2=9개** 입니다. 따라서 현재 **Available 자원**은 12 - 9 = **3개** 입니다.

여기서 Safe sequence를 찾아보려고 합니다. 순서가 `<P1, P0, P2>` 일 때 안전 순서를 만족합니다.

1. `P1`은 2개가 이미 할당되어 있고, 2개를 추가적으로 할당받기를(`Need`) 기다리고 있습니다. 현재 **Available 자원은 3개**이므로, 이 중에 2개를 P1에게 할당해 줍니다. => **현재 Available은 3 - 2 = 1개**
2.  실행이 끝난 `P1`은 자신에게 할당되어 있던 자원 4개를 모두 반납합니다. => **현재 Available은 1 + 4 = 5개**
3.  현재 Available 자원이 5개이고, 이를 **P0에게 모두 할당해 주면** P0도 실행 가능해집니다. => **현재 Available은 5 - 5 = 0개** 가 됩니다.
4. 실행이 끝난 `P0`은 자신에게 할당되어 있던 자원 10개를 모두 반납합니다. => **현재 Available은 0 + 10 = 10개**
5.  마지막으로 `P2`에게 자원 7개를 할당해 줍니다. => **현재 Available은 10 - 7 = 3개**
6.  실행이 끝난 `P2`는 자신에게 할당되어 있던 자원 9개를 모두 반납합니다. => **현재 Available은 3 + 9 = 12개**
<br>
이렇게 자원의 부족함 없이 올바르게 할당하여 모든 프로세스가 실행을 할 수 있었습니다.

만약 여기에서 P2 프로세스가 처음에 자원을 하나 더 할당받고 있었다면(즉, 2개가 아니라 3개) 운영체제가 가지고 있는 Available 자원은 12 - (5+2+3) = **2개** 였을 것입니다.

이 상황에서는 처음에 P1에게 2개를 모두 주고, P1이 실행이 끝나고 자원을 모두 반납해도 **Available 자원은 2 + 2 = 4개 뿐**이므로, 이 자원으로는 나머지 P0이나 P2 프로세스를 해결해 줄 수 없습니다. (모두 4개보다 많은 양의 자원을 필요로 하고 있으므로)

따라서 P0, P2는 자원을 할당받기를 계속 기다려야 할 것입니다.

운영체제가 사전에 P2 프로세스가 자원을 하나 더 요청했을 때 할당해 주지 않고, P1이 먼저 끝나게 한다면 데드락이 발생하지 않았을 것입니다. 그러므로 은행원 알고리즘을 사용해서 **자원 할당량을 사전에 파악하고 데드락을 회피**할 수 있도록 하면 될 것입니다.
<br>
**단점.**
+ 은행원 알고리즘의 경우, **이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건**이 많고, 그에 따른 자원 이용도 하락 등 단점도 존재합니다.
<br>
#### 데드락 발생을 허용하지만 데드락을 **탐지**(detection)하여, **데드락에서 회복**하기
<br>
먼저 시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 **데드락을 탐지하고, 회복하는 알고리즘**을 사용합니다.
<br>
-   **탐지 기법**
    -   Allocation, Request, Available 등으로 시스템에 **데드락이 발생했는지 여부를 탐색**합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악합니다.
    -   이 외에도 **자원 할당 그래프를 통해 탐지**하는 방법도 있습니다.
-   **회복 기법**
    데드락을 탐지 기법을 통해 발견했다면, **`순환 대기`에서 벗어나 데드락으로부터 회복하기 위한 방법**을 사용합니다.
    -   단순히 프로세스를 1개 이상 중단시키기
        -   **교착 상태에 빠진 모든 프로세스를 중단시키는 방법** : 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
        -   **프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법** : 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
    -   자원 선점하기
        -   프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법
<br>
## 4. 내부 단편화와 외부 단편화에 대해 설명해주세요
### 메모리 단편화

-   RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.

#### 1. 내부 단편화

-   메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 현상

![](https://trello-attachments.s3.amazonaws.com/5e8aea3aaf239f64e5fe7306/820x393/d6b06e1de4afa891f98f931148041065/image.png)

-   메모리를 할당하는 최소 블록 크기를 10K라고 가정합시다.  
    만약 7K만큼의 공간을 사용하더라도 10K를 할당해야되고 **나머지 3K를 낭비**하게 됩니다.

#### 2. 외부 단편화

-  메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간에 존재 
-  중간중간에 생긴 사용하지 않는 메모리가 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황
-  여유 공간이 여러 조각으로 나뉘는 현상

![](https://trello-attachments.s3.amazonaws.com/5e8aea3aaf239f64e5fe7306/820x347/3113cb036860ef7b97257f0ca5cc9451/image.png)

-   프로세스 A,B,C 사이의 총 8K의 공간이 남아있습니다.  
    프로세스 D는 7K의 공간을 필요로 하므로, 남은 공간은 충분합니다.  
    그러나 분할하여 할당할 수 없으므로 **프로세스D를 할당할 수 없는 문제가 발생**합니다.

### 메모리 파편화 문제 해결 방법

#### 1. 페이징(Paging)기법 - 가상메모리사용, 외부 단편화 해결, 내부 단편화 존재
>페이징 기법이란 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법.
+ 보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 하고 RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 함
<br>
페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만든다.
페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
대신 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다.
<br>
-   페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.
<br>
#### 2. 세그멘테이션(Segmentation)기법 - 가상메모리사용, 내부 단편화 해결, 외부 단편화 존재
> 페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 가상메모리를   
  서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환
+ 각 세그먼트는 연속적인 공간에 저장되어 있다.
+ 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.

마찬가지로 mapping을 위해 세그먼트 테이블이 필요하다.
(각 세그먼트 항목별 세그먼트 시작주소와 세그먼트의 길이 정보를 가지고 있음)
프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화는 일어나지 않으나   
여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍,   
즉 외부 단편화 문제는 여전히 존재한다.

### 3. 메모리 풀(Memory Pool)
> 필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법

메모리 풀 없이 동적할당과 해제를 반복하면 메모리의 랜덤한(실제로는 알고리즘에 의한) 위치에 할당과 해제가 반복되면서   
단편화를 일으킬 수 있겠지만 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다.

또한 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.

하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다.

메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다.

미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식이다.
<br>
## 5. 페이징 기법에 대해 설명해주세요 + 6.페이징 알고리즘 중 FIFO의 단점에 대해 설명해주세요

**페이징 기법**과 **세그먼테이션 기법**은 **가상 기억장치 구현 기법**으로 주기억장치의 부족한 용량 문제를 해결하기 위해 보조기억장치를 주기억장치처럼 사용할 때 쓰인다.  (= CPU를 속인다.) 

페이징 기법의 키워드는 **동일한 크기**, 세그먼테이션 기법의 키워드는 **서로 다른 크기**인데,
바로 **블록 단위의 크기**를 의미한다. 여기서 블록 단위란?

> **블록 단위**   
> 주기억장치와 보조기억장치의 데이터를 주고받는 최소의 단위

프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억장치에 보관해 놓고, 프로그램 실행 시에 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다. 
주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
블록단위로 나눈다면 연속 할당 방식에서 발생할 수 있는 **단편화를 해결**할 수 있다.

---

### **페이징 기법**

![](https://blog.kakaocdn.net/dn/dhdzz7/btrjUSvYF51/S9xm6WO76We2eANj8XbnkK/img.png)
>페이징은 **프로세스가 사용하는 메모리 공간을 잘게 나누어서 비연속적으로 실제 메모리에 할당하는 메모리 관리 기법**이다. 

페이징 기법이랑 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 **동일한 크기로 나눈 후** 나눠진 프로그램을 동일하게 나눠진 **주기억장치의 영역에 적재시켜 실행하는 기법**이다.

**페이지** : **프로그램**을 일정한 크기로 나눈 단위

**페이지 프레임** : 페이지 크기로 일정하게 나누어진 **주기억장치**의 단위

프로그램의 크기에 따라서, 페이지 크기에 따라서 외부 단편화는 발생하지 않으나 **내부 단편화는 발생할 수 있다.**

실제 프로세스가 실행될 때는 각각의 페이지들이 실제 메모리의 어디에 위치하고 있는지를 빠르게 알 수 있어야 함
+ 주소 변환을 위해 페이지의 위치 정보를 가지고 있는 **페이지 맵 테이블**이 필요하고, 그로 인하여 비용이 증가하고 처리 속도가 감소된다
<br>
 또 프로세스의 입장으로 보면 자신이 사용하고 있는 메모리 공간이 흩어져 있는 페이지들로 구성되는 것이 아니라 하나의 연속된 메모리공간으로 이해할 수 있어야지 프로그램 실행이 효율적이게 된다. 즉 프로세스가 바라보는 메모리의 주소 공간과 실제 메모리의 주소 공간을 논리 주소와 물리 주소라는 것으로 구분을 하고 그들 사이의 변환을 통해서 메모리 참조를 효율적으로 하고자 하는 참조 기법까지도 포함하고 있다. 
 <br>
 이와같이 페이징은 **효율적인 메모리 할당과 프로세스의 효율적인 메모리 참조**라는 두 가지의 메모리 관리의 다 달성하고 있기 때문에 실제 대부분의 운영체제에서 관리하는 기본적인 메모리 관리 기법이라고 할 수 있다. 
<br>
#### 필요조건

**논리 주소 공간과 물리 주소 공간의 분리 - 주소의 동적 재배치 허용**

**전용 하드웨어 (MMU) - 논리 주소와 물리 주소의 변환**

컴퓨터 시스템에 메모리 주소라는 개념을 프로세스의 논리 주소를 한 것과 실제 메모리의 물리 주소로 분리하여 동적으로 논리주소가 물리주소에 재배치되면서 할당되는 것을 허용해야 하고 또 모든 메모리 참조에서 주소변환이 필요하기 때문에 이것을 소프트웨어가 아닌 변환을 전용으로 해주는 MMU가 필요하게 된다.
<br>
#### 프레임 (Frame) & 페이지 (Page)

![](https://blog.kakaocdn.net/dn/s5fhI/btqAKiruCgN/sIoPbQKljmrL0NfJ5eEMKk/img.png)

프로세스가 바라보고 있는 메모리 공간 즉 논리 주소 공간이라는 것은 일정한 크기의 페이지들로 나누어지게 되고 각각의 페이지들은 실제 메모리의 연속된 위치가 아닌 각각의 페이지 별로 임의의 위치에 저장되고 할당 될 수 있다. 
그리고 페이지가 저장된 메모리의 위치 영역을 프레임이라고 한다. 
그래서 **실제 프레임의 크기와 페이지의 크기는 일치**한다.
**프로세스의 메모리 공간을 얘기할 때는 그 단위를 페이지**라고 얘기하고 **실제 메모리에서는 프레임**이라고 얘기한다. 
그리고 일반적인 운영체제에서 페이지와 프레임의 크기는 보통 4KB가 된다. 
그리고 이러한 할당에서 아주 중요한 역할을 하는 것이 page table이다. 
단편 문제는 해결했지만 프로세스가 실행 될 때 자기는 연속된 위치의 메모리라고 이해한 상태로 각각의 페이지가 어디에 있는지를 매번 빠르게 찾을 수 있어야지만이 이 프로세스는 실행이 된다. 
그래서 각각의 페이지가 실제 메모리에 어떤 프레임이 저장이 되는가에 대한 매핑 정보를 담고 있는 페이지 테이블이란 것이 바로 페이징을 운영하는 데에 있어서 매우 중요한 자료 구조이다. 
페이지 테이블은 프레임 번호를 담고있는 배열이고 그것의 인덱스는 페이지 번호를 가리키고 있다고 할 수 있다. 그래서 페이지 번호를 가지고서 인덱스로 직접적으로 접근하게 되면 해당 페이지가 담고있는 프레임을 바로 알 수 있게된다.

[페이징](https://goodmilktea.tistory.com/35)

### 페이지 교체 알고리즘
페이지 교체 알고리즘은 페이징 기법으로 메모리를 관리하는 운영체제에서, 페이지 부재가 발생 하여 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할지를 결정하는 방법입니다.

페이지 교체 알고리즘의 예로, FIFO, LFU, LRU 알고리즘 등이 있습니다.

#### FIFO

FIFO : 페이지가 주기억장치에 적재된 시간을 기준으로 교체될 페이지를 선정하는 기법

단점 : 중요한 페이지가 오래 있었다는 이유만으로 교체되는 불합리. 가장 오래 있었던 페이지는 앞으로 계속 사용될 가능성이 있음.

#### LFU

LFU : 가장 적은 횟수를 참조하는 페이지를 교체

단점 : 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 프로그램을 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드 발생

#### [LRU](https://velog.io/@courage331/LRULeast-Recently-Used-Algorithm)

LRU : 가장 오랫동안 참조되지 않은 페이지를 교체

단점 : 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야함. 큰 오버헤드가 발생
<br>
## 7.세그멘테이션 기법에 대해 설명해주세요

### **세그먼테이션 기법**

![](https://blog.kakaocdn.net/dn/21FrG/btrjVBgKSJm/WL75fs7BdWFeZJYIRFvd40/img.png)

세그먼테이션 기법은 가장기억장치에 보관되어 있는 프로그램을 **다양한 크기의 논리적인 단위**로 나눈 후 주기억장치에 적재시켜 실행시키는 기법이다. 

**프로그램**을 배열이나 함수등과 같은 **논리적인 크기로 나눈 단위를 세그먼트**라고 하며, 각 세그먼트는 **고유한 이름과 크기**를 갖는다. 왜? 주기억장치에 적재될 때 프로그램 A와 B이 같이 담기기 때문에 프로그램의 이름을 꼬리표처럼 써야 한다. 

**세그먼테이션 기법**을 사용하는 이유는 바로 **기억 공간을 절약**하기 위해서!

주소 변환을 위해서는 세그먼트가 존재하는 위치 정보를 가지고 있는 **세그먼트 맵 테이블**이 필요하다. 

내부 단편화는 발생하지 않으나 **외부** **단편화** (주기억 장치의 일부가 남는 현상)는 발생할 수 있다.

프로세스가 **필요하는 전체 논리에 메모리 공간을 한 덩어리로 메모리에 연속적으로 할당하는 것이 아니라 여러개의 작은 단위로 쪼갠 다음에 메모리를 할당한다라는 방법**이 된다. 이것이 페이징하고 다른 점은 페이징에서는 분할하는 단위가 고정된 크기의 페이지 였다면 세그멘테이션에서는 프로그램의 논리적인 단위에 따라 프로세스의 메모리 공간을 구분한다는 것이다. 논리적 단위로는 method, procedure, function, object, variables, stack 등 함수단위로 나눌 수 있고 C컴파일러 관점에서는 코드, 전역 변수, 힙, 스택, 표준 C 라이브러리 단위로 구분지어 나눌 수 있다. 세그먼트의 논리 주소는 세그먼트의 이름(번호)와 오프셋으로 나뉜다.

#### 세그먼트 테이블 (segment table)

세그먼트 테이블에서는 각각의 세그멘트가 차지하는 크기가 서로 다르기 때문에 각 세그멘트가 실제 메모리의 어떤 위치에 저장되어 있느냐라는 정보와 함께 끝 주소 즉 크기까지 같이 포함하고 있는 정보를 가지고 있는 것이 세그멘테이션 세그먼트 테이블이라고 할 수 있다.


#### **메모리 관리 기법**

1.  **연속 메모리 기법**
    -   프로그램 전체가 메모리에 연속적으로 할당
    -   고정 분할 기법 : 메모리가 고정된 파티션으로 분할. **내부 단편화 발생**
    -   동적 분할 기법 : 파티션들이 동적으로 생성되고 자신의 크기와 같은 파티션에 메모리 할당. **외부 단편화 발생**
2.  **불연속 메모리 기법**
    -   프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
    -   Page : 프로세스를 고정된 크기로 나눈 블록
    -   Frame : 메모리를 고정된 크기로 나는 블록
    -   Segment : 서로 다른 크기의 논리적 블록

#### **가상 메모리**

![](https://blog.kakaocdn.net/dn/B8mdX/btrEc3rcdi7/YWqKXJZotCTpzXTM4kCeu1/img.jpg)

-   실제 메모리 크기와 관계없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용
-   프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 할당
-   MMU(Memory Management Unit)를 통해 논리 주소, 물리 주소를 나누어서 사용
-   가상 주소를 주기억장치의 실제적인 주소로 매핑(Mapping)하는 방법을 통해 구현

## 💎 **페이징(Paging)**

![](https://blog.kakaocdn.net/dn/yaaix/btrEdsK3PPJ/0U6gkxhlTGah6p0kg4mrL1/img.png)

-   프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식
-   메모리는 Frame이라는 고정크기로 분할되고, 프로세스는 Page라는 고정크기로 분할됨
-   페이지와 프레임은 크기가 같음
-   페이지와 프레임을 대응시키는 page mapping 과정이 필요하여 paging table을 생성해야 함
-   연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제 해결
-   페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장

  
**But, 프로세스의 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지에 내부 단편화가 발생하고 페이지의 크기가 클수록 내부 단편화가 커짐  
**=> 페이지 단위를 작게 하면 내부 단편화 문제도 해결할 수 있겠지만 page mapping 과정이 많아지므로 효율이 떨어짐

## 💎 **세그멘테이션(Segmentation)**

![](https://blog.kakaocdn.net/dn/22MDs/btrEcQMrq7W/FoKKXCHIBOvfcsu9YvU18k/img.png)

-   프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리에 할당
-   각 세그먼트는 연속적인 공간에 저장
-   세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법
-   페이징과 마찬가지로 mapping을 위한 segment table 필요

**But, 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 중간에 메모리를 해제하면 생기는 외부 단편화 문제가 발생**

## **⚖️ Paging vs Segmentation**

-   Paging은 고정 크기를 가짐
-   Segmentation은 가변 크기를 가짐
-   Paging은 내부 단편화 발생 가능, Segmentation은 외부 단편화 발생 가능