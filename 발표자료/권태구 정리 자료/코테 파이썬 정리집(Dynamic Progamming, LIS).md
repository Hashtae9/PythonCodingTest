# Dynamic Progamming

> **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**



## DP가 적용되기 위해서는 2가지 조건

### 1. Overlapping Subproblems(겹치는 부분 문제)

>  **동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능**

+ **부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.**
  + 이진 탐색 vs 피보나치 수열
    + 특정 데이터를 정렬된 배열 내에서 그 위치를 찾기 때문에 위치를 찾은 후 바로 반환(재사용 x)
    + f(n) = f(n-1) + f(n-2)의 경우 동일한 부분 문제가 중복되어 나타나는 케이스 존재

<img src="https://user-images.githubusercontent.com/101400894/184607050-2e6c5616-154a-4924-ab6a-ed972847fcd4.png" alt="image" style="zoom:80%;" />





### 2. Optimal Substructure(최적 부분 구조)

> **부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**

![image](https://user-images.githubusercontent.com/101400894/184607230-3b04eeb5-8552-4de3-aaaa-11cb6eb8400f.png)

+ 만약, A - B까지의 가장 짧은 경로를 찾고자 하는 경우를 예시로 할 때, 중간에 X가 있을 때, A - X / X - B가 많은 경로 중 가장 짧은 경로라면 전체 최적 경로도 A - X - B가 정답이 된다.



## DP 사용하기

> **특정한 경우에 사용하는** **알고리즘이 아니라 하나의 방법론이므로 다양한 문제해결에 쓰일 수 있다**



### 1.**DP로 풀 수 있는 문제인지 확인**

> 위에서 쓴 **조건들이 충족되는 문제인지를 한 번 체크**

+ 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.



### 2. **문제의 변수 파악**

> 문제 내 변수의 개수 파악(state를 결정할 필요)

+ 예를 들어, **피보나치 수열**에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다.
+ 또한, **문자열 간의 차이**를 구할 때는 문자열의 길이, Edit 거리 등 2가지 변수를 사용한다.
+ 또, 유명한 **Knapsack 문제**에서는 index, 무게로 2가지의 변수를 사용한다.



### 3. **변수 간 관계식 만들기**

> 변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일한 식을 세워야 함 = **점화식**

+ 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축



### 4. 결과값 저장하기

> 관계식까지 정상적으로 생성되었다면 **변수의 값에 따른 결과를 저장**(Memoization)

+ 1~3차원 배열까지 다양한 방법으로 저장



### 5. **기저 상태 파악하기**

> **가장 작은 문제의 상태를 알아야 함** (초기값)

+ **피보나치 수열을 예시로 들면, f(0) = 0, f(1) = 1과 같은 방식**



### 6. 구현하기

#### 	6-1. **Bottom-Up 방식**

> **아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식**

+ 메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.
  + 이러한 방식을 `Tabulation`이라 함
  + 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 **"table-filling"** 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 **Tabulation**이라는 명칭

```python
#DP, Tabulation(Bottom-Up, 상향식)

# 풀이 1.
def fib_Tab1(n):
    
    dp_Tab=[0]*(n+1)
    dp_Tab[0],dp_Tab[1]= 1,1
    
    # 작은 값(소문제)부터 직접 계산하며 진행
    
    # 2항 ~ n항 까지 피보나치 수열항 계산 (0,1 항 = 1)
    for i in range(2,n+1):        
        dp_Tab[i]=dp_Tab[i-1]+dp_Tab[i-2]
    
    print(dp_Tab) # 피보나치 수열 항 리스트 전체 출력
    
    return dp_Tab[n]

fib_Tab(10)

"""
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
output: 89
"""
----------------------------------------------------------------------
#DP, Tabulation(Bottom-Up, 상향식)

# 풀이 2.

def fib_Tab2(n):
	p=[1,1]
	for i in range(2,n+1): # n번째 까지 피보나치 수열 나열
		p.append(p[-1]+p[-2]) # 마지막 2 요소의 합을 리스트에 추가
		print(p)
	return(p[-1]) #피보나치 n번째 값 Return

fib_Tab2(10)
"""
output: 89
"""
```





#### 		6-2. **Top-Down 방식**

> dp[n]의 값을 찾기 위해 **위에서 부터 바로 호출을 시작**하여 dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식

+ f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.
+ 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용
+ 가장 최근의 상태 값을 메모해 두었다고 하여 **Memoization**



```python
# DP, Memoization

dp_Memo=[0]*11
dp_Memo[0]=1
dp_Memo[1]=1

def fib_Memo(n):
    
    #한번도 계산한 적이 없는 경우
    
    if dp_Memo[n]==0: #dp list에 계산한적이 없는경우 0으로 저장되어 있음
        dp_Memo[n] = fib(n-1)+fib(n-2) #재귀로 계산하여 리스트에 값 추가
    
    # 새롭게 추가 값 혹은 저장된 값 반환
    
    return dp_Memo[n]

# 피보나치 수열 항 리스트 전체 출력
for i in range(11):
    fib_Memo(i)

print(dp_Memo)

fib_Memo(10)

"""
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
output: 89
"""
```



### 7. 연산 수행시간 비교

> **메모리 공간을 약간 더 사용**해서 연산 속도를 비약적으로 증가

+ 단순 재귀함수로 구현했을 때 x값이 커짐에 따라 연산 수행시간이 기하급수적으로 늘어남

```python
import time

def fibo(x):
    if x == 1 or x == 2:
        return 1

    return fibo(x-1) + fibo(x-2)

for num in range(5, 40, 10):
    start = time.time()
    res = fibo(num)
    print(res, '-> 러닝타임:', round(time.time() - start, 2), '초')
```

<img src="https://user-images.githubusercontent.com/101400894/194985733-5cba3a84-a453-4c83-ba26-b1e0f3f959e6.png" alt="image" style="zoom:50%;" align="left"/>



+ **메모제이션(캐싱) 기법**

> 한 번 결과를 수행한 것을 메모리에 저장해 놓고 다음에 똑같은 결과가 필요하면 그 때 다시 연산하지 않고 메모리에 저장된 그 값을 가져와 쓰는 것

```
import time

d = [0] * 50

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

for num in range(5, 40, 10):
    start = time.time()
    res = fibo(num)
    print(res, '-> 러닝타임:', round(time.time() - start, 2), '초')
```

<img src="https://user-images.githubusercontent.com/101400894/194985792-ecec6e80-aa50-4ff0-81c1-79002aaba7e4.png" alt="image" style="zoom:50%;" align="left"/>



### 8. 타 알고리즘과의 비교

#### 동적 계획법 vs 분할 정복

- 동적 계획법: 소문제 종속적
  (피보나치 수열): 소문제가 상위 문제에 영향을 끼치며 **원소들이 종속적**이다.
- 분할 정복: 소문제 독립적
  (퀵 정렬, 병합 정렬) : 각각 분할된 원소들이 정렬 과정에서 다른 원소들의 영향을 미치지 않는다.



#### 동적 계획법 vs 탐욕법

- 동적 계획법: 모든 가능성 고려 → **항상 최적의 결과 도출**
- 탐욕법: '현 상태' 에서 가장 최적의 경우를 판단하여 결정 → 문제에 따라 최적해가 구해지지 않을 수 있다.













-----------

*reference*

https://hongjw1938.tistory.com/47